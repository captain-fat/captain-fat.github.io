<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python中正则表达式的使用</title>
    <link href="/2020/02/23/%E9%95%BF%E7%9F%A5%E8%AF%86/ython%E4%B8%AD%E6%94%BF%E7%AD%96%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/23/%E9%95%BF%E7%9F%A5%E8%AF%86/ython%E4%B8%AD%E6%94%BF%E7%AD%96%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p> 正则表达式是一个特殊的字符序列，能方便的检查一个字符串是否与某种模式匹配。re模块使得python拥有全部的正则表达式功能。</p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>通过使用正则表达式，可以：<br>测试字符串内的模式。<br>—— 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为<strong>数据验证</strong>。<br><strong>替换文本</strong>。—— 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。<br>基于模式匹配从字符串中提取子字符串。—— 可以查找文档内或输入域内特定的文本。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><pre><code>&#39;.&#39;     匹配所有字符串，除\n以外&#39;-&#39;     表示范围[0-9]&#39;*&#39;     匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。&#39;+&#39;     匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+&#39;^&#39;     匹配字符串开头&#39;$&#39;     匹配字符串结尾 re&#39;\&#39;     转义字符， 使后一个字符改变原来的意思，如果字符串中有字符*需要匹配，可以\*或者字符集[*] re.findall(r&#39;3\*&#39;,&#39;3*ds&#39;)结[&#39;3*&#39;]&#39;*&#39;     匹配前面的字符0次或多次 re.findall(&quot;ab*&quot;,&quot;cabc3abcbbac&quot;)结果：[&#39;ab&#39;, &#39;ab&#39;, &#39;a&#39;]&#39;?&#39;     匹配前一个字符串0次或1次 re.findall(&#39;ab?&#39;,&#39;abcabcabcadf&#39;)结果[&#39;ab&#39;, &#39;ab&#39;, &#39;ab&#39;, &#39;a&#39;]&#39;{m}&#39;   匹配前一个字符m次 re.findall(&#39;cb{1}&#39;,&#39;bchbchcbfbcbb&#39;)结果[&#39;cb&#39;, &#39;cb&#39;]&#39;{n,m}&#39; 匹配前一个字符n到m次 re.findall(&#39;cb{2,3}&#39;,&#39;bchbchcbfbcbb&#39;)结果[&#39;cbb&#39;]&#39;\d&#39;    匹配数字，等于[0-9] re.findall(&#39;\d&#39;,&#39;电话:10086&#39;)结果[&#39;1&#39;, &#39;0&#39;, &#39;0&#39;, &#39;8&#39;, &#39;6&#39;]&#39;\D&#39;    匹配非数字，等于[^0-9] re.findall(&#39;\D&#39;,&#39;电话:10086&#39;)结果[&#39;电&#39;, &#39;话&#39;, &#39;:&#39;]&#39;\w&#39;    匹配字母和数字，等于[A-Za-z0-9] re.findall(&#39;\w&#39;,&#39;alex123,./;;;&#39;)结果[&#39;a&#39;, &#39;l&#39;, &#39;e&#39;, &#39;x&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;]&#39;\W&#39;    匹配非英文字母和数字,等于[^A-Za-z0-9] re.findall(&#39;\W&#39;,&#39;alex123,./;;;&#39;)结果[&#39;,&#39;, &#39;.&#39;, &#39;/&#39;, &#39;;&#39;, &#39;;&#39;, &#39;;&#39;]&#39;\s&#39;    匹配空白字符 re.findall(&#39;\s&#39;,&#39;3*ds \t\n&#39;)结果[&#39; &#39;, &#39;\t&#39;, &#39;\n&#39;]&#39;\S&#39;    匹配非空白字符 re.findall(&#39;\s&#39;,&#39;3*ds \t\n&#39;)结果[&#39;3&#39;, &#39;*&#39;, &#39;d&#39;, &#39;s&#39;]&#39;\A&#39;    匹配字符串开头&#39;\Z&#39;    匹配字符串结尾&#39;\b&#39;    匹配单词的词首和词尾，单词被定义为一个字母数字序列，因此词尾是用空白符或非字母数字符来表示的&#39;\B&#39;    与\b相反，只在当前位置不在单词边界时匹配[]      是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示相应位置的字符要匹配英文字符和数字。[\s*]表示空格或者*号&#39;(?P&lt;name&gt;...)&#39;  分组，除了原有编号外在指定一个额外的别名 re.search(&quot;(?P&lt;province&gt;[0-9]{4})(?P&lt;city&gt;[0-9]{2})(?P&lt;birthday&gt;[0-9]{8})&quot;,&quot;371481199306143242&quot;).groupdict(&quot;city&quot;) 结果{&#39;province&#39;: &#39;3714&#39;, &#39;city&#39;: &#39;81&#39;, &#39;birthday&#39;: &#39;19930614&#39;}</code></pre><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p><strong>贪婪模式和非贪婪模式</strong></p><p>正则表达式通常使用于查找匹配字符串。python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符；非贪婪模式正好相反，总是尝试匹配尽可能少的字符。<br><strong>使用方法</strong></p><p>在python中默认采用的是贪婪模式，使用非贪婪模式的话，只需要在量词后面直接加上一个问号”?”。</p><p>例子当中已经匹配到了“ab”时已经可以使整个表达式匹配成功，但是由于采用的是贪婪模式，所以还需要往后继续匹配，一直到匹配到最后一个”b”的时候，后面已经没有可以成功匹配的字符串了，匹配结束。返回匹配结果“abbbbbb”。 所以，我们可以将贪婪模式理解为：在整个表达式匹配成功的前提下，尽可能多的匹配。</p><p>非贪婪模式也就是将我们例子中的正则表达式“ab+”改为”ab+?”，当匹配到“ab”时，已经匹配成功，直接结束匹配，不在向后继续尝试，返回匹配成功的字符串”ab”。<br>所以，我们可以将非贪婪模式理解为：在整个表达式匹配成功的前提下，尽可能少的匹配</p><pre><code>import reexample = &quot;&lt;div&gt;test1&lt;/div&gt;&lt;div&gt;test2&lt;/div&gt;&quot;greedPattern = re.compile(&quot;&lt;div&gt;.*&lt;/div&gt;&quot;)notGreedPattern = re.compile(&quot;&lt;div&gt;.*?&lt;/div&gt;&quot;)greedResult = greedPattern.search(example)notGreedResult = notGreedPattern.search(example)print(&quot;greedResult = %s&quot; % greedResult.group())print(&quot;notGreedResult = %s&quot; % notGreedResult.group())[python@master test]$ python3 a.py greedResult = &lt;div&gt;test1&lt;/div&gt;&lt;div&gt;test2&lt;/div&gt;notGreedResult = &lt;div&gt;test1&lt;/div&gt;</code></pre><p>能达到同样匹配结果的贪婪与非贪婪模式，通常是贪婪模式的匹配效率较高。 所有的非贪婪模式，都可以通过修改量词修饰的子表达式，转换为贪婪模式。 贪婪模式可以与固化分组结合，提升匹配效率，而非贪婪模式却不可以。</p><h1 id="使用re模块"><a href="#使用re模块" class="headerlink" title="使用re模块"></a>使用re模块</h1><p><strong>反斜杠的困扰</strong></p><p>在 python 的字符串中，\ 是被当做转义字符的。在正则表达式中，\ 也是被当做转义字符。这就导致了一个问题：如果你要匹配 \ 字符串，那么传递给 re.compile() 的字符串必须是”\\“。</p><p>由于字符串的转义，所以实际传递给 re.compile() 的是”\“，然后再通过正则表达式的转义，”\“ 会匹配到字符”&quot;。这样虽然可以正确匹配到字符 \，但是很麻烦，而且容易漏写反斜杠而导致 Bug。那么有什么好的解决方案呢？</p><p>原始字符串很好的解决了这个问题，通过在字符串前面添加一个r，表示原始字符串，不让字符串的反斜杠发生转义。那么就可以使用r”\“来匹配字符\了。  </p><h2 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile()"></a><strong>re.compile()</strong></h2><p>编译正则表达式模式，返回一个对象。可以把常用的正则表达式编译成正则表达式对象，方便后续调用及提高效率。<br><strong>re.compile(pattern,flags=0)</strong><br><strong>pattern</strong>指定编译时的表达式字符串<br><strong>flags</strong>编译标志位，用来修改正则表达式的匹配方式。支持 re.L|re.M 同时匹配</p><p><strong>flags 标志位参数</strong><br>re.I(re.IGNORECASE)　　　使匹配对大小写不敏感<br>re.L(re.LOCAL)　　　　　　做本地化识别(locale-aware)匹配<br>re.M(re.MULTILINE)　　　　多行匹配，影响 ^ 和 $<br>re.S(re.DOTALL)　　　　　　使 . 匹配包括换行在内的所有字符<br>re.U(re.UNICODE)　　　　　根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.<br>re.X(re.VERBOSE)　　　　　该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</p><pre><code class="python">import recontent = &#39;Citizen wang , always fall in love with neighbour，WANG&#39;rr = re.compile(r&#39;wan\w&#39;, re.I) # 不区分大小写print(type(rr))a = rr.findall(content)print(type(a))print(a)[python@master test]$ python3 b.py &lt;class &#39;re.Pattern&#39;&gt;&lt;class &#39;list&#39;&gt;[&#39;wang&#39;, &#39;WANG&#39;]</code></pre><h2 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h2><p>尝试从一个字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，则返回None。</p><p><strong>re.match(pattern, string, flags=0)</strong></p><p><code>pattern</code>: 待匹配的正则表达式<br><code>string</code>: 待查找的字符串<br><code>flags（可选参数）</code>: 标志位，控制正则表达式的匹配方式。re.I(ignore) re.L(local) re.M(many lines) re.S(sum) re.U(unicode) re.X<br><code>返回值</code>：匹配成功返回匹配对象（group(num=0) / groups() 返回的是一个元组），匹配失败返回None</p><p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式</p><p>group(num=0)匹配的整个表达式的字符串<br>group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</p><p>groups() 返回一个包含所有小组字符串的元组，从 1 到所含的小组号。</p><p>例子1：</p><pre><code class="python"># -*- coding: UTF-8 -*-import reprint(re.match(&#39;www&#39;, &#39;www.runoob.com&#39;).span())  # 在起始位置匹配print(re.match(&#39;com&#39;, &#39;www.runoob.com&#39;))         # 不在起始位置匹配[python@master test]$ python3 d.py (0, 3)None</code></pre><p>例子二：</p><pre><code class="python">[python@master test]$ more c.py import reline = &quot;Cats are Smarter than dogs&quot;# re.M：多行匹配# re.I:忽略大小写进行匹配# match()以元组形式返回匹配成功的对象match_obj = re.match(r&quot;(.*) are (.*?) .*&quot;, line, re.M | re.I)if match_obj:    print(&quot;match_obj.group(): &quot;, match_obj.group())    print(&quot;match_obj.group(1): &quot;, match_obj.group(1))    print(&quot;match_obj.group(2): &quot;, match_obj.group(2))    print(&quot;match_obj.group(3): &quot;, match_obj.group(1,2))    print(&quot;match_obj.groups(): &quot;, match_obj.groups())else:    print(&quot;None match!&quot;)print(&quot;*&quot; * 98)[python@master test]$ python3 c.py match_obj.group():  Cats are Smarter than dogsmatch_obj.group(1):  Catsmatch_obj.group(2):  Smartermatch_obj.group(3):  (&#39;Cats&#39;, &#39;Smarter&#39;)match_obj.groups():  (&#39;Cats&#39;, &#39;Smarter&#39;)</code></pre><h2 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h2><p>扫描整个字符串并返回第一个成功的匹配。<br>函数语法：<br><strong>re.search(pattern, string, flags=0)</strong><br>函数参数说明：<br><code>pattern</code>      匹配的正则表达式<br><code>string</code>          要匹配的字符串。<br><code>flags</code>            标志位，用于控制正则表达式  的匹配方式，如：是否区分大小写，多行匹配等等。</p><p>匹配成功re.search方法返回一个匹配的对象，否则返回None。<br>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。<br>group(num=0)匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。<br>groups()返回一个包含所有小组字符串的元组，从1到所含的小组号。</p><p>例子1：</p><pre><code class="python">[python@master test]$ more a.py # -*- coding: UTF-8 -*- import reprint(re.search(&#39;www&#39;, &#39;www.runoob.com&#39;).span())  # 在起始位置匹配print(re.search(&#39;com&#39;, &#39;www.runoob.com&#39;).span())         # 不在起始位置匹配[python@master test]$ python3 a.py (0, 3)(11, 14)</code></pre><p>例子2：</p><pre><code class="python">[python@master test]$ more b.py import reline = &quot;Cats are smarter than dogs&quot;;searchObj = re.search( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I)if searchObj:   print(&quot;searchObj.group() : &quot;, searchObj.group())   print(&quot;searchObj.group(1) : &quot;, searchObj.group(1))   print(&quot;searchObj.group(2) : &quot;, searchObj.group(2))else:   print(&quot;Nothing found!!&quot;)[python@master test]$ python3 b.py searchObj.group() :  Cats are smarter than dogssearchObj.group(1) :  CatssearchObj.group(2) :  smarter</code></pre><h2 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h2><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；<br>而re.search匹配整个字符串，直到找到一个匹配。</p><pre><code class="python">[python@master test]$ more c.py import reline = &quot;Cats are smarter than dogs&quot;;matchObj = re.match( r&#39;dogs&#39;, line, re.M|re.I)if matchObj:   print(&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())else:   print(&quot;No match!!&quot;)matchObj = re.search( r&#39;dogs&#39;, line, re.M|re.I)if matchObj:   print(&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())else:   print(&quot;No match!!&quot;)[python@master test]$ python3 c.py No match!!search --&gt; matchObj.group() :  dogs</code></pre><h2 id="re-sub"><a href="#re-sub" class="headerlink" title="re.sub()"></a>re.sub()</h2><p>Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。<br>语法：<br><strong>re.sub(pattern, repl, string, count=0, flags=0)</strong><br>参数：<br><code>pattern</code>       正则中的模式字符串。<br><code>repl</code>            替换的字符串，也可为一个函数。<br><code>string</code>         要被查找替换的原始字符串。<br><code>count</code>         模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</p><pre><code class="python">[python@master test]$ more d.pyimport rephone = &quot;2004-959-559 # 这是一个电话号码&quot;# 删除注释num = re.sub(r&#39;#.*$&#39;, &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num)# 移除非数字的内容num = re.sub(r&#39;\D&#39;, &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num)[python@master test]$ python3 d.py 电话号码 :  2004-959-559 电话号码 :  2004959559</code></pre><p><strong>repl 参数是一个函数</strong></p><p>以下实例中将字符串中的匹配的数字乘于 2</p><pre><code class="python">[python@master test]$ more e.py import re# 将匹配的数字乘于 2def double(matched):    value = int(matched.group(&#39;value&#39;))    return str(value * 2)s = &#39;A23G4HFD567&#39;print(re.sub(&#39;(?P&lt;value&gt;\d+)&#39;, double, s))[python@master test]$ python3 e.py A46G8HFD1134</code></pre><h2 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h2><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。<br>注意： match 和 search 是匹配一次 findall 匹配所有。<br>语法格式为：<br><strong>findall(string[, pos[, endpos]])</strong><br>参数：<br><code>string</code>          待匹配的字符串。<br><code>pos</code>              可选参数，指定字符串的起始位置，默认为 0。<br><code>endpos</code>           可选参数，指定字符串的结束位置，默认为字符串的长度。    </p><p>查找字符串中的所有数字：</p><pre><code class="python">[python@master test]$ more a.py import repattern = re.compile(r&#39;\d+&#39;)   # 查找数字result1 = pattern.findall(&#39;runoob 123 google 456&#39;)result2 = pattern.findall(&#39;run88oob123google456&#39;, 0, 10)print(result1)print(result2)[python@master test]$ python3 a.py [&#39;123&#39;, &#39;456&#39;][&#39;88&#39;, &#39;12&#39;]</code></pre><h2 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer()"></a>re.finditer()</h2><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。<br><strong>re.finditer(pattern, string, flags=0)</strong><br>参数：<br><code>pattern</code>         匹配的正则表达式<br><code>string</code>         要匹配的字符串。<br><code>flags</code>           标志位，用于控制正则表达式的  匹配方式，如：是否区分大小写，多行匹配等等。</p><pre><code class="python">[python@master test]$ more d.py import reit = re.finditer(r&quot;\d+&quot;,&quot;12a32bc43jf3&quot;) for match in it:     print (match.group() )[python@master test]$ python3 d.py 1232433</code></pre><h2 id="re-split"><a href="#re-split" class="headerlink" title="re.split()"></a>re.split()</h2><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：<br><strong>re.split(pattern, string[, maxsplit=0, flags=0])</strong><br>参数：<br><code>pattern</code>           匹配的正则表达式<br><code>string</code>           要匹配的字符串。<br><code>maxsplit</code>         分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。<br><code>flags</code>             标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等  </p><pre><code class="python">&gt;&gt;&gt; re.split(&#39;\W+&#39;,&#39;runoob,runoob,runoob.&#39;)[&#39;runoob&#39;, &#39;runoob&#39;, &#39;runoob&#39;, &#39;&#39;]&gt;&gt;&gt; re.split(&#39;(\W+)&#39;,&#39; runoob,runoob,runoob.&#39;) [&#39;&#39;, &#39; &#39;, &#39;runoob&#39;, &#39;,&#39;, &#39;runoob&#39;, &#39;,&#39;, &#39;runoob&#39;, &#39;.&#39;, &#39;&#39;]&gt;&gt;&gt; re.split(&#39;\W+&#39;, &#39; runoob, runoob, runoob.&#39;, 1) [&#39;&#39;, &#39;runoob, runoob, runoob.&#39;]&gt;&gt;&gt; re.split(&#39;a&#39;, &#39;hello world&#39;)[&#39;hello world&#39;]# 对于一个找不到匹配的字符串而言，split 不会对其作出分割</code></pre><h1 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h1><p><strong>re.RegexObject</strong><br>re.compile() 返回 RegexObject 对象。<br><strong>re.MatchObject</strong><br>   group() 返回被 RE 匹配的字符串。<br>   start() 返回匹配开始的位置<br>   end()   返回匹配结束的位置<br>   span()  返回一个元组包含匹配 (开始,结束) 的位置     </p><h1 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h1><p>模式字符串使用特殊的语法来表示一个正则表达式：<br>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。<br>多数字母和数字前加一个反斜杠时会拥有不同的含义。<br>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。<br>反斜杠本身需要使用反斜杠转义。<br>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\t’，等价于 \t )匹配相应的特殊字符。<br>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p><pre><code>^                 匹配字符串的开头$                 匹配字符串的末尾。.                 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。[...]             用来表示一组字符,单独列出：[amk] 匹配 &#39;a&#39;，&#39;m&#39;或&#39;k&#39;[^...]            不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。re*               匹配0个或多个的表达式。re+               匹配1个或多个的表达式。re?               匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式re{ n}            匹配n个前面表达式。例如，&quot;o{2}&quot;不能匹配&quot;Bob&quot;中的&quot;o&quot;，但是能匹配&quot;food&quot;中的两个o。re{ n,}           精确匹配n个前面表达式。例如，&quot;o{2,}&quot;不能匹配&quot;Bob&quot;中的&quot;o&quot;，但能匹配&quot;foooood&quot;中的所有o。&quot;o{1,}&quot;等价于&quot;o+&quot;。&quot;o{0,}&quot;则等价于&quot;o*&quot;。re{ n, m}         匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式a| b              匹配a或b(re)              匹配括号内的表达式，也表示一个组(?imx)            正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。(?-imx)           正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。(?: re)           类似 (...), 但是不表示一个组(?imx: re)        在括号中使用i, m, 或 x 可选标志(?-imx: re)       在括号中不使用i, m, 或 x 可选标志(?#...)           注释.(?= re)           前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。(?! re)           前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。(?&gt; re)           匹配的独立模式，省去回溯。\w                匹配数字字母下划线\W                匹配非数字字母下划线\s                匹配任意空白字符，等价于 [\t\n\r\f]。\S                匹配任意非空字符\d                匹配任意数字，等价于 [0-9]。\D                匹配任意非数字\A                匹配字符串开始\Z                匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。\z                匹配字符串结束\G                匹配最后匹配完成的位置。\b                匹配一个单词边界，也就是指单词和空格间的位置。例如， &#39;er\b&#39; 可以匹配&quot;never&quot; 中的 &#39;er&#39;，但不能匹配 &quot;verb&quot; 中的 &#39;er&#39;。\B                匹配非单词边界。&#39;er\B&#39; 能匹配 &quot;verb&quot; 中的 &#39;er&#39;，但不能匹配 &quot;never&quot; 中的 &#39;er&#39;。\n, \t, 等。       匹配一个换行符。匹配一个制表符, 等\1...\9           匹配第n个分组的内容。\10               匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</code></pre><h1 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h1><pre><code>[Pp]ython           匹配 &quot;Python&quot; 或 &quot;python&quot;    rub[ye]               匹配 &quot;ruby&quot; 或 &quot;rube&quot;          [aeiou]               匹配中括号内的任意一个字母     [0-9]                   匹配任何数字。类似于 [0123456789][a-z]                   匹配任何小写字母                 [A-Z]                  匹配任何大写字母                 [a-zA-Z0-9]        匹配任何字母及数字         [^aeiou]              除了aeiou字母以外的所有字符  [^0-9]                 匹配除了数字外的字符</code></pre><h1 id="特殊字符类"><a href="#特殊字符类" class="headerlink" title="特殊字符类"></a>特殊字符类</h1><pre><code>.                  匹配除 &quot;\n&quot; 之外的任何单个字符。要匹配包括 &#39;\n&#39; 在内的任何字符，请使用象 &#39;[.\n]&#39; 的模式。    \d                匹配一个数字字符。等价于 [0-9]。                                                       \D                匹配一个非数字字符。等价于 [^0-9]。                                                    \s                匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。                 \S                匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                                            \w                匹配包括下划线的任何单词字符。等价于&#39;[A-Za-z0-9_]&#39;。                                   \W               匹配任何非单词字符。等价于 &#39;[^A-Za-z0-9_]&#39;。  </code></pre><blockquote><p>参考:<a href="https://www.cnblogs.com/hello-wei/p/10181055.html" target="_blank" rel="noopener">https://www.cnblogs.com/hello-wei/p/10181055.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式练习</title>
    <link href="/2020/02/23/%E9%95%BF%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0/"/>
    <url>/2020/02/23/%E9%95%BF%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>昨天学了点正则表达式，最后一个是实验课，需要写一个小爬虫，获取百度搜索关键词相应搜索页面的第一页，然后利用正则表达式选出其中的是个搜索结果的标题然后输入</p></blockquote><h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a><strong>整体思路</strong></h1><ul><li>构建GUI，一个输入文本框(获取关键词)，一个开始按钮，一个输出文本框框(输出搜索结果)</li><li>获得网页源代码，根据输入的关键词生成地址，并找到该地址的源码以便下一步使用</li><li>利用正则表达式对网页源码进行筛选，找到相应的搜索结果转换成字符串并输出</li></ul><h2 id="构建GUI"><a href="#构建GUI" class="headerlink" title="构建GUI"></a><strong>构建GUI</strong></h2><p>利用Pyqt带的Designer设计的<br><img src="/images/pasted-24.png" srcset="/img/loading.gif" alt="1"><br>上面的文本框输入文字，开始按钮，下面的大文本框输出文字</p><h2 id="网页源码爬取"><a href="#网页源码爬取" class="headerlink" title="网页源码爬取"></a><strong>网页源码爬取</strong></h2><p>一开始想用urllib进行爬取，不过好像百度有反扒机制，一开始没有加head头和后面加了head头都不行，会返回一个安全验证的页面<br><img src="/images/pasted-25.png" srcset="/img/loading.gif" alt="2"></p><pre><code class="python">import urllib.requesthead = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&#39;}url = &quot;http://www.baidu.com/s&quot;data = {    &#39;wd&#39;: &quot;nihong&quot;}data = urllib.parse.urlencode(data)  # 编码工作，由dict转成stringfull_url = url + &#39;?&#39; + data  # Get请求发送request = urllib.request.Request(url = full_url, headers = head)response = urllib.request.urlopen(request)print(response.read().decode(&#39;utf-8&#39;))</code></pre><p>后面采用的是模拟浏览器渲染的方式，selenuim进行源码的爬取，但是速度会比较慢因为涉及到浏览器的渲染  </p><h2 id="正则表达式使用"><a href="#正则表达式使用" class="headerlink" title="正则表达式使用"></a><strong>正则表达式使用</strong></h2><p>用火狐的检查和谷歌浏览器的检查貌似代码顺序会不一样<br><img src="/images/pasted-26.png" srcset="/img/loading.gif" alt="火狐浏览器"></p><blockquote><p>火狐浏览器<br><img src="/images/pasted-27.png" srcset="/img/loading.gif" alt="谷歌浏览器"><br>谷歌浏览器</p></blockquote><p>一开始没发现的时候坑了好久<br>最终的正则表达式：</p><pre><code>&lt;div\s+class=&quot;(result|result-op)\s+c-container\s+.*?&lt;a.*?&gt;(.*?)&lt;/a&gt;</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="python">from main_window import Ui_MainWindowfrom PyQt5.QtWidgets import  QMainWindow, QApplicationfrom selenium import webdriverfrom selenium.webdriver.chrome.options import  Optionsimport timeimport urllibimport reimport sysclass my_main_window(QMainWindow, Ui_MainWindow):    def __init__(self):        super(my_main_window, self).__init__()        self.setupUi(self)        self.btn_start.clicked.connect(self.read_imput_text)        self.btn_start.clicked.connect(self.get_words)    def read_imput_text(self):        input_text = self.text_inputbox.toPlainText()        #配置浏览器，关闭界面        chrome_opt = Options()        chrome_opt.add_argument(&#39;---windows-size=1366,768&#39;)        chrome_opt.add_argument(&#39;--headless&#39;)        chrome_opt.add_argument(&#39;--disable-pu&#39;)        #配置url        url = &quot;http://www.baidu.com/s&quot;        data = {&#39;wd&#39;:input_text}        full_url = url + &#39;?&#39; + urllib.parse.urlencode(data)        #获取页面源码        browser = webdriver.Chrome(options=chrome_opt)        browser.get(full_url)        time.sleep(2)        self.page = browser.page_source        print(self.page)        browser.quit()    def get_words(self):        #正则表达式，提取关键词        pattern = re.compile(r&#39;&lt;div\s+class=&quot;(result|result-op)\s+c-container\s+.*?&lt;a.*?&gt;(.*?)&lt;/a&gt;&#39;, re.I | re.S)        results = re.finditer(pattern, self.page)        result = []        for i in results:            result.append(i.group(2))        pattern_clean = re.compile(r&quot;&lt;em&gt;|&lt;/em&gt;|&#39;|\[|\]&quot;, re.I | re.S)        clean_result = re.sub(pattern_clean, &#39;&#39;, str(result))        self.text_outputbox.setText(clean_result)if __name__ == &#39;__main__&#39;:    app = QApplication(sys.argv)    myWin = my_main_window()    myWin.show()    sys.exit(app.exec())</code></pre>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式学习</title>
    <link href="/2020/02/22/%E9%95%BF%E7%9F%A5%E8%AF%86/%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/02/22/%E9%95%BF%E7%9F%A5%E8%AF%86/%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基本认识和元字符"><a href="#基本认识和元字符" class="headerlink" title="基本认识和元字符"></a>基本认识和元字符</h1><p>*任意长度字符串<br>？长度为1的任意字符串  </p><h2 id="元字符概念"><a href="#元字符概念" class="headerlink" title="元字符概念"></a><strong>元字符概念</strong></h2><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配出换行符外任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a><strong>反义</strong></h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母或数字或下划线或汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词的开始或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了X意外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母意外的任意字符</td></tr></tbody></table><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a><strong>字符转义</strong></h2><ul><li>匹配.或者?这样的字符</li><li>转义字符\</li><li>.*?</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><p><img src="/images/pasted-14.png" srcset="/img/loading.gif" alt="1"></p><h1 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h1><h2 id="重复模式"><a href="#重复模式" class="headerlink" title="重复模式"></a>重复模式</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或者更多次</td></tr><tr><td>+</td><td>重复一次或者多次</td></tr><tr><td>？</td><td>重复零次或者一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或者更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><p><img src="/images/pasted-15.png" srcset="/img/loading.gif" alt="2"><br>|表示分支条件  </p><blockquote><p>条件1：  </p></blockquote><p>0\d{2}-\d{8}<br>0然后两位数字-八位数字  </p><blockquote><p>条件二  </p></blockquote><p>0然后三位数字-七位数字<br>如果满足条件一就不执行条件二了</p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p><img src="/images/pasted-16.png" srcset="/img/loading.gif" alt="3"><br>(?0\d{2}[)-]?\d{8}<br>（出现零次或者一次，然后0接下来两位数字，)-打包出现零次，然后八位数字<br><em>这个左右括号没有做平衡</em>  </p><h1 id="分组-amp-贪婪与懒惰"><a href="#分组-amp-贪婪与懒惰" class="headerlink" title="分组&amp;贪婪与懒惰"></a>分组&amp;贪婪与懒惰</h1><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p><img src="/images/pasted-18.png" srcset="/img/loading.gif" alt="4"></p><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p><img src="/images/pasted-13.png" srcset="/img/loading.gif" alt="5"></p><p><strong>懒惰</strong>  </p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+？</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>？？</td><td>重复0次或者1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr><tr><td>## 处理选项</td><td></td></tr></tbody></table><p><img src="/images/pasted-17.png" srcset="/img/loading.gif" alt="6"></p><h1 id="高阶讲解"><a href="#高阶讲解" class="headerlink" title="高阶讲解"></a>高阶讲解</h1><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p><img src="/images/pasted-19.png" srcset="/img/loading.gif" alt="7"></p><h2 id="零宽断言（真假）"><a href="#零宽断言（真假）" class="headerlink" title="零宽断言（真假）"></a>零宽断言（真假）</h2><p><img src="/images/pasted-20.png" srcset="/img/loading.gif" alt="8"></p><h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p><img src="/images/pasted-21.png" srcset="/img/loading.gif" alt="9"></p><h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p><img src="/images/pasted-22.png" srcset="/img/loading.gif" alt="10"></p><p><strong>例子</strong></p><p><img src="/images/pasted-23.png" srcset="/img/loading.gif" alt="11"></p><pre><code>&lt;                                        #最外层的左括号    [^&lt;&gt;]*                               #最外层的左括号后面的不是括号的内容    (       (           (?&#39;Open&#39;&lt;)                    #碰到了左括号，在黑板上写一个“open”          |           (?&#39;-Open&#39;&gt;)                   #碰到了右括号，擦掉一个“open”          |  [^&lt;&gt;]*                      #匹配右括号后面不是括号的内容       )+    )*    (?(Open)(?!))                        #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的“open”，有的话匹配失败&gt;                                        #最外层的右括号</code></pre><p><em>仅支持.net</em></p><blockquote><p>参考资料：<a href="https://www.bilibili.com/video/av47287083?p=10" target="_blank" rel="noopener">https://www.bilibili.com/video/av47287083?p=10</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python爬虫一：分析豆瓣中正在上映的电影短评</title>
    <link href="/2020/02/21/%E9%95%BF%E7%9F%A5%E8%AF%86/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B8%80%EF%BC%9A%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E4%B8%AD%E6%9C%80%E6%96%B0%E7%94%B5%E5%BD%B1%E7%9A%84%E5%BD%B1%E8%AF%84/"/>
    <url>/2020/02/21/%E9%95%BF%E7%9F%A5%E8%AF%86/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B8%80%EF%BC%9A%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E4%B8%AD%E6%9C%80%E6%96%B0%E7%94%B5%E5%BD%B1%E7%9A%84%E5%BD%B1%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p>用python写爬虫抓取豆瓣短评并进行词云展示</p><h1 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h1><p>主要做了三件事：</p><ul><li>抓取网页数据</li><li>清理数据</li><li>进行词云展示</li></ul><h1 id="抓取网页数据"><a href="#抓取网页数据" class="headerlink" title="抓取网页数据"></a>抓取网页数据</h1><p><strong>第一步要对网页进行访问，python中使用的是urllib库。代码如下：</strong></p><pre><code class="python">import urlliburl = &#39;https://movie.douban.com/cinema/nowplaying/suzhou/&#39;head = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&#39;}request = urllib.request.Request(url = url, headers = head)resp = urllib.request.urlopen(request)html_data = resp.read().decode(&#39;utf-8&#39;)print(html_data)</code></pre><p>其中<a href="https://movie.douban.com/cinema/nowplaying/suzhou/" target="_blank" rel="noopener">https://movie.douban.com/cinema/nowplaying/suzhou/</a> ，可以在浏览器中输入该网址进行查看。<br>html_data是字符串类型的变量，里面存放了网页的html代码。<br>输入print(html_data)可以查看，如下图所示：</p><p><img src="/images/pasted-2.png" srcset="/img/loading.gif" alt="图片1"></p><p><strong>第二步，需要对得到的html代码进行解析，从里面提取我们需要的数据。</strong><br>在python中使用BeautifulSoup库进行html代码的解析。<br><del>（注：如果没有安装此库，则使用pip install BeautifulSoup进行安装即可！）<br>BeautifulSoup使用的格式如下：</del><br>pip install BeautifulSoup4</p><pre><code class="python">BeautifulSoup(html,&quot;html.parser&quot;)</code></pre><p>第一个参数为需要提取数据的html，第二个参数是指定解析器，然后使用find_all()读取html标签中的内容.  </p><p>但是html中有这么多的标签，该读取哪些标签呢？其实，最简单的办法是可以打开我们爬取网页的html代码，然后查看我们需要的数据在哪个html标签里面，再进行读取就可以了。如下图所示：</p><p><img src="/images/pasted-3.png" srcset="/img/loading.gif" alt="图片2"><br>从上图中可以看出在<em>div id=”nowplaying”</em>标签开始是我们想要的数据，里面有电影的名称、评分、主演等信息。所以相应的代码编写如下：</p><pre><code class="python">from bs4 import BeautifulSoup as bssoup = bs(html_data, &#39;html.parser&#39;)nowplaying_movie = soup.find_all(&#39;div&#39;, id=&#39;nowplaying&#39;)nowplaying_movie_list = nowplaying_movie[0].find_all(&#39;li&#39;, class_=&#39;list-item&#39;)</code></pre><pre><code class="python">nowplaying_list = [] for item in nowplaying_movie_list:                nowplaying_dict = {}                nowplaying_dict[&#39;id&#39;] = item[&#39;data-subject&#39;]               for tag_img_item in item.find_all(&#39;img&#39;):                        nowplaying_dict[&#39;name&#39;] = tag_img_item[&#39;alt&#39;]                        nowplaying_list.append(nowplaying_dict)  </code></pre><p><img src="/images/pasted-4.png" srcset="/img/loading.gif" alt="图片3"></p><p>可以看到和豆瓣网址上面是匹配的。这样就得到了最新电影的信息了。接下来就要进行对最新电影短评进行分析了。例如《战狼2》的短评网址为：<a href="https://movie.douban.com/subject/26363254/comments?start=0&amp;limit=20" target="_blank" rel="noopener">https://movie.douban.com/subject/26363254/comments?start=0&amp;limit=20</a><br>其中26363254就是电影的id，start=0表示评论的第0条评论。</p><p>接下来接对该网址进行解析了。打开上图中的短评页面的html代码，我们发现关于评论的数据是在div标签的comment属性下面，如下图所示：</p><p><img src="/images/pasted-5.png" srcset="/img/loading.gif" alt="图片4"></p><p>因此对此标签进行解析，代码如下：</p><pre><code class="python">requrl = &#39;https://movie.douban.com/subject/&#39; + nowplaying_list[0][&#39;id&#39;] + &#39;/comments&#39; +&#39;?&#39; +&#39;start=0&#39; + &#39;&amp;limit=20&#39;resp = urllib.request.Request(url = requrl, headers = head)resp = urllib.request.urlopen(resp)html_data = resp.read().decode(&#39;utf-8&#39;)soup = bs(html_data, &#39;html.parser&#39;)comment_div_list = soup.find_all(&#39;div&#39;, class_ = &#39;comment&#39;)</code></pre><pre><code class="python">eachCommentList = []for item in comment_div_list:    if item.find_all(&#39;span&#39;, &#39;short&#39;)[0].string is not None:        eachCommentList.append(item.find_all(&#39;span&#39;, &#39;short&#39;)[0].string)</code></pre><p><img src="/images/pasted-7.png" srcset="/img/loading.gif" alt="图片5"></p><p>好的，至此我们已经爬取了豆瓣最近播放电影的评论数据，接下来就要对数据进行清洗和词云显示了。</p><h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><p>为了方便进行数据进行清洗，我们将列表中的数据放在一个字符串数组中，代码如下：</p><pre><code class="python">comments = &#39;&#39;for k in range(len(eachCommentList)):    comments = comments + (str(eachCommentList[k])).strip()</code></pre><p>使用print(comments)进行查看，如下图所示：</p><p><img src="/images/pasted-8.png" srcset="/img/loading.gif" alt="图片6"></p><p>可以看到所有的评论已经变成一个字符串了，但是我们发现评论中还有不少的标点符号等。这些符号对我们进行词频统计时根本没有用，因此要将它们清除。所用的方法是正则表达式。python中正则表达式是通过re模块来实现的。代码如下：</p><pre><code class="python">pattern = re.compile(r&#39;[\u4e00-\u9fa5]+&#39;)filterdata = re.findall(pattern, comments)cleaned_comments = &#39;&#39;.join(filterdata)</code></pre><p><img src="/images/pasted-9.png" srcset="/img/loading.gif" alt="7"><br>我们可以看到此时评论数据中已经没有那些标点符号了，数据变得“干净”了很多。</p><p>因此要进行词频统计，所以先要进行中文分词操作。在这里我使用的是结巴分词。如果没有安装结巴分词，可以在控制台使用pip install jieba进行安装。</p><pre><code class="python">import jiebaimport pandas as pdsegment = jieba.lcut(cleaned_comments)words_df = pd.DataFrame({&#39;segment&#39;:segment})</code></pre><p>因为结巴分词要用到pandas，所以我们这里加载了pandas包。可以使用words_df.head()查看分词之后的结果，如下图所示：</p><p><img src="/images/pasted-10.png" srcset="/img/loading.gif" alt="8"><br>从上图可以看到我们的数据中有“看”、“太”、“的”等虚词（停用词），而这些词在任何场景中都是高频词，并且没有实际的含义，所以我们要将他们清除。</p><p>我把停用词放在一个stopwords.txt文件中，将我们的数据与停用词进行比对即可（注：<a href="https://github.com/captain-fat/short_text_classification/tree/master/conf" target="_blank" rel="noopener">https://github.com/captain-fat/short_text_classification/tree/master/conf</a> ）<br>去停用词代码如下：</p><pre><code class="python">stopwords = pd.read_csv(&#39;chineseStopWords.txt&#39;,index_col=False,quoting=3,sep=&quot;\t&quot;,names=[&#39;stopword&#39;], encoding=&#39;gb18030&#39;)#可能用&#39;utf-8&#39;words_df = words_df[~words_df.segment.isin(stopwords.stopword)]</code></pre><p>继续使用words_df.head()语句来查看结果，如下图所示，停用词已经被除去了。<br><img src="/images/pasted-11.png" srcset="/img/loading.gif" alt="9"></p><p>接下来就要进行词频统计了，代码如下：</p><pre><code class="python">import numpy as npwords_stat = words_df.groupby(by=[&#39;segment&#39;])[&#39;segment&#39;].agg({&quot;计数&quot;:np.size})words_stat = words_stat.reset_index().sort_values(by=[&#39;计数&#39;], ascending = False)</code></pre><blockquote><p>FutureWarning: using a dict on a Series for aggregation<br>is deprecated and will be removed in a future version. Use                 named aggregation instead.   </p><blockquote><blockquote><p>grouper.agg(name_1=func_1, name_2=func_2)<br>  “””Entry point for launching an IPython kernel.</p></blockquote></blockquote></blockquote><h1 id="词云展示"><a href="#词云展示" class="headerlink" title="词云展示"></a>词云展示</h1><p>代码如下：</p><pre><code class="python">import matplotlib.pyplot as plt%matplotlib inlineimport matplotlibmatplotlib.rcParams[&#39;figure.figsize&#39;] = (10.0, 5.0)from wordcloud import WordCloud#词云包wordcloud=WordCloud(font_path=&quot;simhei.ttf&quot;,background_color=&quot;white&quot;,max_font_size=80) #指定字体类型、字体大小和字体颜色word_frequence = {x[0]:x[1] for x in words_stat.head(1000).values}word_frequence_list = []for key in word_frequence:    temp = (key,word_frequence[key])    word_frequence_list.append(temp)word_frequence_list = dict(word_frequence_list)wordcloud=wordcloud.fit_words(word_frequence_list)plt.imshow(wordcloud)</code></pre><p><img src="/images/pasted-12.png" srcset="/img/loading.gif" alt="结果"></p><p>完整程序</p><pre><code class="python">import urllibfrom bs4 import BeautifulSoup as bsimport reimport jiebaimport pandas as pdimport numpy as npurl = &#39;https://movie.douban.com/cinema/nowplaying/suzhou/&#39;head = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&#39;}request = urllib.request.Request(url = url, headers = head)resp = urllib.request.urlopen(request)html_data = resp.read().decode(&#39;utf-8&#39;)print(html_data)soup = bs(html_data, &#39;html.parser&#39;)nowplaying_movie = soup.find_all(&#39;div&#39;, id=&#39;nowplaying&#39;)nowplaying_movie_list = nowplaying_movie[0].find_all(&#39;li&#39;, class_=&#39;list-item&#39;)nowplaying_list = []for item in nowplaying_movie_list:    nowplaying_dict = {}    nowplaying_dict[&#39;id&#39;] = item[&#39;data-subject&#39;]    for tag_img_item in item.find_all(&#39;img&#39;):        nowplaying_dict[&#39;name&#39;] = tag_img_item[&#39;alt&#39;]        nowplaying_list.append(nowplaying_dict)requrl = &#39;https://movie.douban.com/subject/&#39; + nowplaying_list[0][&#39;id&#39;] + &#39;/comments&#39; +&#39;?&#39; +&#39;start=0&#39; + &#39;&amp;limit=20&#39;resp = urllib.request.Request(url = requrl, headers = head)resp = urllib.request.urlopen(resp)html_data = resp.read().decode(&#39;utf-8&#39;)soup = bs(html_data, &#39;html.parser&#39;)comment_div_list = soup.find_all(&#39;div&#39;, class_ = &#39;comment&#39;)eachCommentList = []for item in comment_div_list:    if item.find_all(&#39;span&#39;, &#39;short&#39;)[0].string is not None:        eachCommentList.append(item.find_all(&#39;span&#39;, &#39;short&#39;)[0].string)comments = &#39;&#39;for k in range(len(eachCommentList)):    comments = comments + (str(eachCommentList[k])).strip()pattern = re.compile(r&#39;[\u4e00-\u9fa5]+&#39;)filterdata = re.findall(pattern, comments)cleaned_comments = &#39;&#39;.join(filterdata)segment = jieba.lcut(cleaned_comments)words_df = pd.DataFrame({&#39;segment&#39;:segment})stopwords = pd.read_csv(&#39;chineseStopWords.txt&#39;,index_col=False,quoting=3,sep=&quot;\t&quot;,names=[&#39;stopword&#39;], encoding=&#39;gb18030&#39;)words_df = words_df[~words_df.segment.isin(stopwords.stopword)]words_stat = words_df.groupby(by=[&#39;segment&#39;])[&#39;segment&#39;].agg({&quot;计数&quot;:np.size})words_stat = words_stat.reset_index().sort_values(by=[&#39;计数&#39;], ascending = False)import matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;figure.figsize&#39;] = (10.0, 5.0)from wordcloud import WordCloud#词云包wordcloud=WordCloud(font_path=&quot;simhei.ttf&quot;,background_color=&quot;white&quot;,max_font_size=80) #指定字体类型、字体大小和字体颜色word_frequence = {x[0]:x[1] for x in words_stat.head(1000).values}word_frequence_list = []for key in word_frequence:    temp = (key,word_frequence[key])    word_frequence_list.append(temp)word_frequence_list = dict(word_frequence_list)wordcloud=wordcloud.fit_words(word_frequence_list)plt.imshow(wordcloud)</code></pre><p>参考：<br><a href="https://segmentfault.com/a/1190000010473819" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010473819</a></p>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown用法（转载）</title>
    <link href="/2020/02/19/%E9%95%BF%E7%9F%A5%E8%AF%86/arkdown%E7%94%A8%E6%B3%95/"/>
    <url>/2020/02/19/%E9%95%BF%E7%9F%A5%E8%AF%86/arkdown%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级的<strong>「标记语言」</strong>，优点在于</p><ul><li><p>专注你的文字内容而不是排版样式。</p></li><li><p>轻松的导出 HTML、PDF 和本身的 .md 文件。</p></li><li><p>纯文本内容，兼容所有的文本编辑器与字处理软件。</p></li><li><p>可读，直观。适合所有人的写作语言。</p><blockquote><p>并且具有以下特点：</p></blockquote></li><li><p>自动生成目录</p></li><li><p>代码块高亮</p></li><li><p>引用展示</p></li><li><p>表格插入</p></li><li><p>图片插入</p></li><li><p>强调显示</p></li><li><p>列表显示</p></li><li><p>自动URL链接  </p></li></ul><blockquote><p>Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。</p></blockquote><h1 id="语法简明概述"><a href="#语法简明概述" class="headerlink" title="语法简明概述"></a>语法简明概述</h1><p>分段 两个回车<br>换行 两个空格 + 回车<br>标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题<br>强调 <strong>文字</strong> ， <strong>文字</strong> ， <em>文字</em> ， <em>文字</em> ， <del>文字</del><br>引用 &gt; 注意后面紧跟个空格<br>表格 - 和 | 分割行和列 ， : 控制对其方式<br>代码块 四个空格 开头或， 使用<code>代码内容</code><br>链接 <a href="链接地址">文字</a><br>图片 <img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" srcset="/img/loading.gif" alt="图片说明"> ，地址可以是本地路劲，也可以是网络地址<br>列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><pre><code class="markdown"># 欢迎使用Markdown编辑器写博客   //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入                     //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题                    //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题                   //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题                  //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题                 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt;####### 七级标题                //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行）二级标题                        //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;----                           //这里添加四个&#39;－&#39; （减号）</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><pre><code class="markdown">这是一级标题===这是二级标题---</code></pre><p>该方法仅支持二级标题</p><blockquote><p>这里不做展示了，影响目录的展示。</p></blockquote><h1 id="内容强调"><a href="#内容强调" class="headerlink" title="内容强调"></a>内容强调</h1><h2 id="加粗、斜体"><a href="#加粗、斜体" class="headerlink" title="加粗、斜体"></a>加粗、斜体</h2><pre><code class="markdown">字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示</code></pre><p>字体 <strong>加粗</strong> 显示<br>字体 <em>斜体</em> 显示<br>字体 <strong><em>加粗并斜体</em></strong> 显示</p><pre><code class="markdown">字体 __加粗__ 显示字体 _斜体_ 显示字体 ___加粗并斜体___ 显示组合 *__加粗并斜体__* 显示</code></pre><p>字体 <strong>加粗</strong> 显示<br>字体 <em>斜体</em> 显示<br>字体 <strong><em>加粗并斜体</em></strong> 显示<br>组合 <em><strong>加粗并斜体</strong></em> 显示  </p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><pre><code class="markdown">这样来 ~~删除一段文本~~</code></pre><p>这样来 <del>删除一段文本</del></p><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><pre><code class="markdown">使用&lt;code&gt;\`&lt;/code&gt;来强调字符   //想打出  ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调  比如`突出背景色`来显示强调效果</code></pre><p>使用<code>`</code>来强调字符<br>比如<code>突出背景色</code>来显示强调效果</p><h2 id="引用显示"><a href="#引用显示" class="headerlink" title="引用显示"></a>引用显示</h2><p>引用过程中任然支持Markdown语法！</p><h3 id="标准使用"><a href="#标准使用" class="headerlink" title="标准使用"></a>标准使用</h3><pre><code class="markdown">&gt; 每行开始都使用 &#39;&gt;&#39;；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。  &gt; 还在引用中！两个回车结束引用！</code></pre><blockquote><p>每行开始都使用 ‘&gt;’；<br>引用<strong>开始</strong>；<br>引用<strong>换行</strong>；<br>引用<strong>结束</strong>。<br>还在引用中！<br>两个回车结束引用！</p></blockquote><h3 id="省略使用"><a href="#省略使用" class="headerlink" title="省略使用"></a>省略使用</h3><pre><code class="markdown">&gt; 仅第一行加应用；引用**开始**；引用**换行**；引用**结束**；两个回车结束引用,不在引用范围内了！</code></pre><blockquote><p>仅第一行加应用；<br>引用<strong>开始</strong>；<br>引用<strong>换行</strong>；<br>引用<strong>结束</strong>；  </p></blockquote><p>两个回车结束引用,不在引用范围内了！</p><h3 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h3><pre><code class="markdown">&gt; 动物&gt;&gt; 水生动物&gt;&gt; 陆生动物&gt;&gt;&gt; 猴子&gt;&gt;&gt; 人&gt;&gt;&gt;&gt; 程序猿&gt;&gt;&gt;&gt; 攻城狮&gt;&gt;产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱   //这里需要注意，没有空行间隔，忽略降级引用标记&gt;&gt; 两栖类动物&gt;&gt;&gt; 大鳄鱼唐老鸭两个回车结束引用,不在引用范围内了！</code></pre><blockquote><p>动物</p><blockquote><p>水生动物<br>陆生动物</p><blockquote><p>猴子<br>人</p><blockquote><p>程序猿<br>攻城狮<br>产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记<br>射鸡虱   //这里需要注意，没有空行间隔，忽略降级引用标记<br>两栖类动物<br>大鳄鱼<br>唐老鸭<br>两个回车结束引用,不在引用范围内了！</p></blockquote></blockquote></blockquote></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表格语法：</p><pre><code class="markdown">列1   | 列2 | 列3 ----- | --- | ---- 第1行 | 12  | 13  第2行 | 22  | 23  第3行 | 32  | 33</code></pre><table><thead><tr><th>列1</th><th>列2</th><th>列3</th></tr></thead><tbody><tr><td>第1行</td><td>12</td><td>13</td></tr><tr><td>第2行</td><td>22</td><td>23</td></tr><tr><td>第3行</td><td>32</td><td>33</td></tr></tbody></table><p>可以使用冒号来定义对齐方式：</p><pre><code class="markdown">| 左对齐    |  右对齐 | 居中 || :-------- | -------:| :--: || Computer  | 5000 元 |  1台 || Phone     | 1999 元 |  1部 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">5000 元</td><td align="center">1台</td></tr><tr><td align="left">Phone</td><td align="right">1999 元</td><td align="center">1部</td></tr></tbody></table><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>代码块语法遵循标准 markdown 代码，使用 <code>开始，</code> 结束，例如：</p><pre><code class="Python">#!/usr/bin/env python# -*- coding: utf-8 -*-print &#39;Hello World!</code></pre><pre><code>以上代码框及代码输入内容</code></pre><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-print &#39;Hello World!&#39;</code></pre><h2 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h2><p>如何在代码块中打出 ```</p><pre><code class="markdown">    ````    ```    复制到你的`markdown`中看看去吧！    ```    ````</code></pre><p>实际上是使用 4个<code>包含 3个</code> 就可以了，想表示更多，最外层+1就好了。</p><pre><code class="markdown">    ````    ```    ```    ````</code></pre><h1 id="链接插入"><a href="#链接插入" class="headerlink" title="链接插入"></a>链接插入</h1><pre><code class="markdown">[首页](http://yifan.press)[我的信息](/about/)</code></pre><p><a href="http://yifan.press">首页</a><br><a href="/about/">我的信息</a></p><p>图片插入</p><pre><code class="markdown">![我的头像](http://yifan.press/img/avatar.png)![我的头像](images/avatar.png)</code></pre><p><img src="https//yifan.press/img/avatar.png" srcset="/img/loading.gif" alt="我的头像"><br><img src="/images/avatar.png" srcset="/img/loading.gif" alt="我的头像"></p><h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><pre><code class="markdown">***---</code></pre><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><pre><code class="markdown">* `*`列表展示* `*`列表展示 * `*`列表展示+ `+`列表展示+ `+`列表展示 + `+`列表展示- `-`列表展示- `-`列表展示 - `-`列表展示</code></pre><ul><li><code>*</code>列表展示</li><li><code>*</code>列表展示<ul><li><code>*</code>列表展示</li></ul></li></ul><ul><li><code>+</code>列表展示</li><li><code>+</code>列表展示<ul><li><code>+</code>列表展示</li></ul></li></ul><ul><li><code>-</code>列表展示</li><li><code>-</code>列表展示<ul><li><code>-</code>列表展示</li></ul></li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>这种方式不用手动设置序号，自动生成列表序列</p><pre><code class="markdown">1. **我是一级序列** 1. **我是一级序列** 1. **我是一级序列**  1. *我是二级序列*  1. *我是二级序列*  1. *我是二级序列* 1. **我是一级序列** 1. **我是一级序列**  1. *我是二级序列*  1. *我是二级序列*   1. 还是二级序列，没有三级序列\</code></pre><ol><li><strong>我是一级序列</strong> </li><li><strong>我是一级序列</strong> </li><li><strong>我是一级序列</strong> <ol><li><em>我是二级序列</em> </li><li><em>我是二级序列</em> </li><li><em>我是二级序列</em> </li></ol></li><li><strong>我是一级序列</strong> </li><li><strong>我是一级序列</strong> <ol><li><em>我是二级序列</em> </li><li><em>我是二级序列</em> </li><li>还是二级序列，没有三级序列\序列一个空格，但是任然是二级序列</li></ol></li></ol><h1 id="链接自动检测"><a href="#链接自动检测" class="headerlink" title="链接自动检测"></a>链接自动检测</h1><pre><code class="markdown">首页:http://yifan.press我的信息:http://yifan.press/about/</code></pre><p>首页:<a href="http://yifan.press">http://yifan.press</a><br>我的信息:<a href="http://yifan.press/about/">http://yifan.press/about/</a></p><h1 id="特殊符号处理"><a href="#特殊符号处理" class="headerlink" title="特殊符号处理"></a>特殊符号处理</h1><pre><code class="markdown">\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><blockquote><p>本文作者： zhuzhuxia<br>本文链接： <a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html</a><br>温馨提示： 由于原创文章，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。  </p></blockquote><blockquote><p>感谢：<a href="https://www.jianshu.com/p/335db5716248" target="_blank" rel="noopener">https://www.jianshu.com/p/335db5716248</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫-get请求示例</title>
    <link href="/2020/02/19/%E9%95%BF%E7%9F%A5%E8%AF%86/%E7%88%AC%E8%99%AB-get%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/"/>
    <url>/2020/02/19/%E9%95%BF%E7%9F%A5%E8%AF%86/%E7%88%AC%E8%99%AB-get%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>GET请求一般用于我们向服务器查询的过程，比如说，百度搜索“宁哥的小站”，如图所示，浏览器的url会跳转成如图所示</p><p><img src="/images/pasted-0.png" srcset="/img/loading.gif" alt="图像1"></p><p>在其中我们可以看到在”<a href="http://www.baidu.com/s?”" target="_blank" rel="noopener">http://www.baidu.com/s?”</a> 之后出现一个长长的字符串，其中就包含我们要查询的关键词。那么，我们在编程过程中，如何配置这段字符串参数呢？</p><p>在Chrome浏览器中，我们可以看到，请求的数据包含在请求头的Query String Parameters中，其实我们可以将这些字段都写在程序中，也可以摘取其中必要的部分，而不是全部。</p><p><img src="/images/pasted-1.png" srcset="/img/loading.gif" alt="图像2"></p><p>比较关键的是wd字段，这里我们只是把wd字段提取出来，写成词典，然后通过程序编码，配置成GET请求的url，再通过一般的程序抓取手段，可以得到我们查询的页面。程序如下：</p><p>  <strong><em>urllib有些用法变了，更新了下(2020/2/19)</em></strong></p><pre><code class="python">import urlliburl = &quot;http://www.baidu.com/s&quot;data = {    &#39;wd&#39;: &quot;测试&quot;}data = urllib.parse.urlencode(data) #编码工作，由dict转成stringfull_url = url + &#39;?&#39; + data #Get请求发送print(full_url)response = urllib.request.urlopen(full_url)print(response.read())</code></pre><p>转载请注明：宁哥的小站 » 3. 网络爬虫-GET请求示例</p>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>巴意行</title>
    <link href="/2020/02/17/%E5%B7%B4%E6%84%8F%E8%A1%8C/"/>
    <url>/2020/02/17/%E5%B7%B4%E6%84%8F%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please.." data-whm="Sorry, wrong hash."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Hey, password is required here." /><label>Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="3be2431fcdba7d480bcf762626301caf29037b7ec5530fb60df7d0c6e4e9e27b">f2fd406b5d28eb48ecc341e8ed8ec46e6fa5bb41eb4dbadcdaab53489ae1f1364f690a8268b6f97b0ddd89addfc744dd007a212c7d95604e89950e77b7f84df6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2020/02/17/test/"/>
    <url>/2020/02/17/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/02/16/hello-world/"/>
    <url>/2020/02/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
