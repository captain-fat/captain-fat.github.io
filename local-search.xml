<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android学习</title>
    <link href="/2020/03/20/%E9%95%BF%E7%9F%A5%E8%AF%86/ndroid%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/03/20/%E9%95%BF%E7%9F%A5%E8%AF%86/ndroid%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Basic-View"><a href="#Basic-View" class="headerlink" title="Basic View"></a>Basic View</h1><h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><p><strong>Reformat Code</strong>      <code>ctrl+alt+l</code></p><pre><code class="java">//TextView所呈现的文字android:text=&quot;我爱Java&quot;//文字颜色android:textColor=&quot;#f00&quot;//文字尺寸android:textSize=&quot;20pt&quot;//文本框结尾处绘制图片  android:drawableEnd=&quot;@drawable/ic_launcher&quot;//不管内容多长，单行显示android:singleLine=&quot;true“//文字过长时，中间部分省略android:ellipsize=&quot;middle&quot;//全部字母大写android:textAllCaps=&quot;true&quot;//若文字为email或者电话号码，以特殊形式呈现android:autoLink=&quot;email|phone&quot;//文字为密码，以点代替android:password=&quot;true&quot;//文字阴影相关android:shadowColor=&quot;#0000ff&quot;android:shadowDx=&quot;10.0&quot;android:shadowDy=&quot;8.0&quot;android:sha5dowRadius=&quot;3.0&quot;//指定背景图案android:background=&quot;@drawable/bg_border&quot;</code></pre><blockquote><p><strong>java文件中修改</strong></p></blockquote><pre><code class="java">TextView textView = findViewById(R.id.mTextView);textView.setText(&quot;Test&quot;);textView.setTextColor(Color.Red);</code></pre><blockquote><p>跑马灯**</p></blockquote><pre><code class="java">android:focusable=&quot;true&quot;   android:marqueeRepeatLimit=&quot;marquee_forever&quot;android:ellipsize=&quot;marquee&quot;android:scrollHorizontally=&quot;true&quot;android:focusableInTouchMode=&quot;true&quot;android:singleLine=&quot;true&quot;//4.0以上需加</code></pre><h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><pre><code class="java">android:src=&quot;@mipmap/ic_launcher&quot;</code></pre><h2 id="Button-amp-ImageViewButton"><a href="#Button-amp-ImageViewButton" class="headerlink" title="Button &amp; ImageViewButton"></a>Button &amp; ImageViewButton</h2><pre><code class="xml">&lt;Button        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/mButton&quot;/&gt;&lt;ImageButton        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:src=&quot;@mipmap/ic_launcher&quot;        android:id=&quot;@+id/mImageButton&quot;/&gt;</code></pre><blockquote><p><strong>Java代码</strong></p></blockquote><pre><code class="java">Button mButton = findViewById(R.id.mButton);ImageButton mImageButton = findViewById(R.id.mImageButton);</code></pre><ul><li><p>匿名内部内方法实现setOnClickListener</p><pre><code class="java">mButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                Log.i(&quot;button&quot;, &quot;我被点击了&quot;);                Toast.makeText(MainActivity.this, &quot;Test&quot;, Toast.LENGTH_SHORT).show();            }        });</code></pre></li><li><p>接口</p><pre><code class="java">public class MainActivity extends AppCompatActivity implements View.OnClickListener {    @Override    public void onClick(View v) {        Log.i(&quot;Button&quot;, &quot;我又被点击了&quot;);        Toast.makeText(MainActivity.this, &quot;Test&quot;, Toast.LENGTH_SHORT).show();    }}</code></pre><p><em>先寻找控件,再setOnClickListener, 否则会空指针</em></p></li></ul><h2 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h2><pre><code class="xml">  &lt;EditText          android:hint=&quot;请输入用户名&quot;          android:phoneNumber=&quot;true&quot;          android:layout_width=&quot;wrap_content&quot;          android:layout_height=&quot;wrap_content&quot;          android:id=&quot;@+id/mEditText&quot;          android:password=&quot;true&quot;          /&gt;</code></pre><pre><code class="java">  private CharSequence temp;  TextView mTextView = findViewById(R.id.mTextView);  mTextView.addTextChangedListener(new TextWatcher() {              @Override              public void beforeTextChanged(CharSequence s, int start, int count, int after) {                  temp = s;              }              @Override              public void onTextChanged(CharSequence s, int start, int before, int count) {              }              @Override              public void afterTextChanged(Editable s) {                  if(temp.length()&gt;10){                      Toast.makeText(MainActivity.this, &quot;超过字数限制&quot;, Toast.LENGTH_SHORT).show();                  }              }          });</code></pre><h2 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h2><pre><code class="xml">   &lt;CheckBox          android:layout_width=&quot;wrap_content&quot;          android:layout_height=&quot;wrap_content&quot;          android:text=&quot;是否记住密码&quot;          android:id=&quot;@+id/mCheckBox&quot;/&gt;</code></pre><pre><code class="java">  CheckBox mCheckBox = findViewById(R.id.mCheckBox);  mButton.setOnClickListener(new View.OnClickListener() {              @Override              public void onClick(View v) {                  if (mCheckBox.isChecked()){                      Toast.makeText(MainActivity.this, &quot;选中了&quot;, Toast.LENGTH_LONG).show();                  }              }          });</code></pre><h2 id="RadioButton"><a href="#RadioButton" class="headerlink" title="RadioButton"></a>RadioButton</h2><pre><code class="xml">  &lt;RadioGroup          android:layout_width=&quot;wrap_content&quot;          android:layout_height=&quot;wrap_content&quot;          android:id=&quot;@+id/RG1&quot;&gt;&gt;          &lt;RadioButton              android:id=&quot;@+id/mRB1&quot;              android:layout_width=&quot;wrap_content&quot;              android:layout_height=&quot;wrap_content&quot;              android:checked=&quot;true&quot;              android:text=&quot;One&quot; /&gt;          &lt;RadioButton              android:id=&quot;@+id/mRB2&quot;              android:layout_width=&quot;wrap_content&quot;              android:layout_height=&quot;wrap_content&quot;              android:text=&quot;True&quot; /&gt;      &lt;/RadioGroup&gt;</code></pre><pre><code class="java">  RadioGroup RG = findViewById(R.id.RG1);  RG.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {          @Override          public void onCheckedChanged(RadioGroup group, int checkedId) {              if (checkedId == R.id.mRB1){                  Toast.makeText(MainActivity.this, &quot;One&quot;, Toast.LENGTH_LONG).show();                  }              else if(checkedId == R.id.mRB2){                  Toast.makeText(MainActivity.this, &quot;Two&quot;, Toast.LENGTH_LONG).show();                  }              }          });</code></pre><h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><pre><code class="xml">  &lt;ProgressBar          android:layout_width=&quot;match_parent&quot;          android:id=&quot;@+id/mPB&quot;          android:layout_height=&quot;wrap_content&quot;          style=&quot;?android:attr/progressBarStyleHorizontal&quot;          /&gt;</code></pre><p>  android:progressBarStyle：默认进度条样式</p><p>  android:progressBarStyleHorizontal：水平样式</p><pre><code class="java">  private ProgressBar mPB;  mPB = findViewById(R.id.mPB);  private int flag = 0;  //子线程  private Handler handler = new Handler(){      @Override      public void handleMessage(@NonNull Message msg) {          switch(msg.what){              case 100:                  mPB.setProgress(flag);                  flag++;                  if (flag &lt; 100){                      handler.sendEmptyMessageDelayed(100, 100);               }               break;          }      }  };  mImageButton.setOnClickListener(new View.OnClickListener() {      @Override      public void onClick(View v) {          handler.sendEmptyMessageDelayed(100, 100);          }      });</code></pre><p>  getMax()：返回这个进度条的范围的上限</p><p>  getProgress()：返回进度</p><p>  getSecondaryProgress()：返回次要进度</p><p>  incrementProgressBy(int diff)：指定增加的进度</p><p>  isIndeterminate()：指示进度条是否在不确定模式下</p><p>  setIndeterminate(boolean indeterminate)：设置不确定模式下</p><h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><pre><code class="xml">&lt;ScrollView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:orientation=&quot;vertical&quot;&gt;            &lt;RadioButton                android:id=&quot;@+id/mRB2&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                android:text=&quot;True&quot; /&gt;            ------------        &lt;/LinearLayout&gt;&lt;/ScrollView&gt;</code></pre><h2 id="五大布局"><a href="#五大布局" class="headerlink" title="五大布局"></a>五大布局</h2><h3 id="LinearLayout-线性布局"><a href="#LinearLayout-线性布局" class="headerlink" title="LinearLayout 线性布局"></a><strong>LinearLayout</strong> <strong>线性布局</strong></h3><p>LinearLayout按照垂直或者水平的顺序依次排列子元素，每一个子元素都位于前一个元素之后。如果是垂直排列，那么将是一个N行单列的结构，每一行只会有一个元素，而不论这个元素的宽度为多少；如果是水平排列，那么将是一个单行N列的结构。如果搭建两行两列的结构，通常的方式是先垂直排列两个元素，每一个元素里再包含一个LinearLayout进行水平排列。</p><p>LinearLayout中的子元素属性android:layout_weight生效，它用于描述该子元素在剩余空间中占有的大小比例。加入一行只有一个文本框，那么它的默认值就为0，如果一行中有两个等长的文本框，那么他们的android:layout_weight值可以是同为1。如果一行中有两个不等长的文本框，那么他们的android:layout_weight值分别为1和2，那么第一个文本框将占据剩余空间的三分之二，第二个文本框将占据剩余空间中的三分之一。android:layout_weight遵循数值越小，重要度越高的原则</p><h3 id="FrameLayout-帧布局"><a href="#FrameLayout-帧布局" class="headerlink" title="FrameLayout 帧布局"></a><strong>FrameLayout</strong> <strong>帧布局</strong></h3><p>FrameLayout是五大布局中最简单的一个布局，在这个布局中，整个界面被当成一块空白备用区域，所有的子元素都不能被指定放置的位置，它们统统放于这块区域的左上角，并且后面的子元素直接覆盖在前面的子元素之上，将前面的子元素部分和全部遮挡。显示效果如下，第一个TextView被第二个TextView完全遮挡，第三个TextView遮挡了第二个TextView的部分位置。</p><h3 id="AbsoluteLayout-绝对布局"><a href="#AbsoluteLayout-绝对布局" class="headerlink" title="AbsoluteLayout  绝对布局"></a><strong>AbsoluteLayout</strong>  <strong>绝对布局</strong></h3><p>AbsoluteLayout是绝对位置布局。在此布局中的子元素的android:layout_x和android:layout_y属性将生效，用于描述该子元素的坐标位置。屏幕左上角为坐标原点（0,0），第一个0代表横坐标，向右移动此值增大，第二个0代表纵坐标，向下移动，此值增大。在此布局中的子元素可以相互重叠。在实际开发中，通常不采用此布局格式，因为它的界面代码过于刚性，以至于有可能不能很好的适配各种终端。</p><h3 id="RelativeLayout-相对布局"><a href="#RelativeLayout-相对布局" class="headerlink" title="RelativeLayout 相对布局"></a><strong>RelativeLayout</strong> <strong>相对布局</strong></h3><p>RelativeLayout按照各子元素之间的位置关系完成布局。在此布局中的子元素里与位置相关的属性将生效。例如android：layout_below, android:layout_above等。子元素就通过这些属性和各自的ID配合指定位置关系。注意在指定位置关系时，引用的ID必须在引用之前，先被定义，否则将出现异常。</p><p>RelativeLayout是Android五大布局结构中最灵活的一种布局结构，比较适合一些复杂界面的布局。下面示例就展示这么一个情况，第一个文本框与父组件的底部对齐，第二个文本框位于第一个文本框的上方，并且第三个文本框位于第二个文本框的左方。</p><blockquote><p><strong>RelativeLayout里常用的位置属性如下：</strong></p></blockquote><ul><li>android:layout_toLeftOf —— 该组件位于引用组件的左方</li><li>android:layout_toRightOf —— 该组件位于引用组件的右方</li><li>android:layout_above —— 该组件位于引用组件的上方</li><li>android:layout_below —— 该组件位于引用组件的下方</li><li>android:layout_alignParentLeft —— 该组件是否对齐父组件的左端</li><li>android:layout_alignParentRight —— 该组件是否齐其父组件的右端</li><li>android:layout_alignParentTop —— 该组件是否对齐父组件的顶部</li><li>android:layout_alignParentBottom —— 该组件是否对齐父组件的底部</li><li>android:layout_centerInParent —— 该组件是否相对于父组件居中</li><li>android:layout_centerHorizontal —— 该组件是否横向居中</li><li>android:layout_centerVertical —— 该组件是否垂直居中</li></ul><h3 id="TableLayout-表格布局"><a href="#TableLayout-表格布局" class="headerlink" title="TableLayout 表格布局"></a><strong>TableLayout</strong> <strong>表格布局</strong></h3><p>TableLayout顾名思义，此布局为表格布局，适用于N行N列的布局格式。一个TableLayout由许多TableRow组成，一个TableRow就代表TableLayout中的一行。</p><p>TableRow是LinearLayout的子类，它的android:orientation属性值恒为horizontal，并且它的android:layout_width和android:layout_height属性值恒为MATCH_PARENT和WRAP_CONTENT。所以它的子元素都是横向排列，并且宽高一致的。这样的设计使得每个TableRow里的子元素都相当于表格中的单元格一样。在TableRow中，单元格可以为空，但是不能跨列。</p><h2 id="AndroidnManifes"><a href="#AndroidnManifes" class="headerlink" title="AndroidnManifes"></a>AndroidnManifes</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.example.viewpager&quot;&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;    &lt;---权限---&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h1 id="Senior-View"><a href="#Senior-View" class="headerlink" title="Senior View"></a>Senior View</h1><h2 id="VideoView"><a href="#VideoView" class="headerlink" title="VideoView"></a>VideoView</h2><blockquote><p><strong>步骤</strong></p></blockquote><p>1、在界面布局文件中定义VideoView组件，或在程序中创建VideoView组件</p><p> 2、调用VideoView的如下两个方法来加载指定的视频</p><p>​     setVidePath(String path)：加载path文件代表的视频</p><p>​     setVideoURI(Uri uri)：加载uri所对应的视频</p><p>3、调用VideoView的start()、stop()、psuse()方法来控制视频的播放</p><p>//路径</p><p>videoview.setVideoURI(Uri.parse(“android.resource://“+getPackageName()+”/“+R.raw.media)); </p><p>//播放 </p><p>videoview.start();</p><p>//监听</p><p>setOnCompletionListener</p><pre><code class="xml">&lt;VideoView        android:id=&quot;@+id/video&quot;        android:layout_width=&quot;400dp&quot;        android:layout_height=&quot;400dp&quot; /&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;Button            android:id=&quot;@+id/start&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;start&quot; /&gt;        &lt;Button            android:id=&quot;@+id/stop&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;stop&quot; /&gt;        &lt;Button            android:id=&quot;@+id/pause&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;pause&quot; /&gt;        &lt;Button            android:id=&quot;@+id/resume&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;resume&quot; /&gt;    &lt;/LinearLayout&gt;</code></pre><pre><code class="java">package com.example.vidioview;import android.media.MediaPlayer;import android.net.Uri;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.VideoView;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity implements View.OnClickListener {    @Override    public void onClick(View v) {        if (v.getId() == R.id.start){            videoView.start();        }        else if (v.getId() == R.id.pause){            videoView.pause();        }        else if(v.getId() == R.id.stop){            videoView.stopPlayback();        }        else if(v.getId() == R.id.resume){            videoView.resume();            }        }    private VideoView videoView;//定义控件    private Button btn_start, btn_stop, btn_pause, btn_resume;    /**    *初始化    */    private void initView() {        btn_resume = findViewById(R.id.resume);        btn_resume.setOnClickListener(this);        videoView = findViewById(R.id.video);        btn_stop = findViewById(R.id.stop);        btn_stop.setOnClickListener(this);        btn_start = findViewById(R.id.start);        btn_start.setOnClickListener(this);        btn_pause = findViewById(R.id.pause);        btn_pause.setOnClickListener(this);        /**         * 加载视频         */        videoView.setVideoURI(Uri.parse(&quot;android.resource://&quot; + getPackageName()+&quot;/&quot;+ R.raw.video));//视频移到raw文件夹后点下sync同步下资源        videoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {            @Override            public void onCompletion(MediaPlayer mp) {                videoView.start();            }        });    }    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initView();    }}</code></pre><h2 id="Spinner"><a href="#Spinner" class="headerlink" title="Spinner"></a>Spinner</h2><p>Spinner提供了从一个数据集合中快速选择一项值的办法。默认情况下Spinner显示的是当前选择的值，点击Spinner会弹出一个包含所有可选值的dropdown菜单，从该菜单中可以为Spinner选择一个新值。</p><pre><code class="xml">&lt;Spinner        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/mSpinner&quot;/&gt;</code></pre><pre><code class="java">package com.example.spinner;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Spinner;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    //下拉菜单    private Spinner mSpinner;    //数据    private String[] data = {&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;};    //数据源, 给容器加载数据用    private ArrayAdapter&lt;String&gt;adapter;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mSpinner = findViewById(R.id.mSpinner);        /**         * 上下文         * 布局文件/样式         * 数据         */        adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, data);        mSpinner.setAdapter(adapter);        //监听        mSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {            //选中执行            @Override            public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) {                Toast.makeText(MainActivity.this, data[position], Toast.LENGTH_LONG).show();            }            @Override            public void onNothingSelected(AdapterView&lt;?&gt; parent) {            }        });    }}</code></pre><h2 id="TabHost"><a href="#TabHost" class="headerlink" title="TabHost"></a>TabHost</h2><p>activity_main.xml</p><pre><code class="xml">&lt;TabHost        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:id=&quot;@android:id/tabhost&quot;&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:orientation=&quot;vertical&quot;&gt;            &lt;TabWidget                android:id=&quot;@android:id/tabs&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot; /&gt;            &lt;FrameLayout                android:id=&quot;@android:id/tabcontent&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;match_parent&quot;&gt;                &lt;LinearLayout                    android:id=&quot;@+id/tab1&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;match_parent&quot;                    android:orientation=&quot;vertical&quot;&gt;                &lt;/LinearLayout&gt;                &lt;LinearLayout                    android:id=&quot;@+id/tab2&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;match_parent&quot;                    android:orientation=&quot;vertical&quot;&gt;                &lt;/LinearLayout&gt;                &lt;LinearLayout                    android:id=&quot;@+id/tab3&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;match_parent&quot;                    android:orientation=&quot;vertical&quot;&gt;                &lt;/LinearLayout&gt;            &lt;/FrameLayout&gt;        &lt;/LinearLayout&gt;    &lt;/TabHost&gt;</code></pre><p>activity_tab1.xml</p><pre><code class="xml">&lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;首页&quot;        android:textSize=&quot;50dp&quot;/&gt;</code></pre><p>在AndroidManife注册</p><pre><code class="xml">&lt;activity android:name=&quot;.Tab1Activity&quot;/&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>Tab1Activity.java</p><pre><code class="java">package com.example.tabhost;import android.os.Bundle;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;public class Tab1Activity extends AppCompatActivity {    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_tab1);    }}</code></pre><p>MainActivity</p><pre><code class="java">package com.example.tabhost;import androidx.appcompat.app.AppCompatActivity;import android.app.ActionBar;import android.app.TabActivity;import android.content.Intent;import android.os.Bundle;import android.widget.TabHost;public class MainActivity extends TabActivity {    //选项卡    private TabHost mTabHost;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //直接获取到TabHost 相当于FindViewById        //需要把TabHost的ID改成系统id:android:id=&quot;@android:id/tabhost&quot;        mTabHost = getTabHost();        //初始化        mTabHost.setup();        TabHost.TabSpec tabSpec1 = mTabHost.newTabSpec(&quot;tab1&quot;).setIndicator(&quot;首页&quot;).setContent(new Intent(this, Tab1Activity.class));        TabHost.TabSpec tabSpec2 = mTabHost.newTabSpec(&quot;tab2&quot;).setIndicator(&quot;新闻&quot;).setContent(new Intent(this, Tab1Activity.class));        TabHost.TabSpec tabSpec3 = mTabHost.newTabSpec(&quot;tab3&quot;).setIndicator(&quot;设置&quot;).setContent(new Intent(this, Tab1Activity.class));        mTabHost.addTab(tabSpec1);        mTabHost.addTab(tabSpec2);        mTabHost.addTab(tabSpec3);    }}</code></pre><p>TabHost组件可以在界面中存放多个选项卡, 很多软件都使用了该组件进行设计;</p><p><strong>TabWidget</strong> : 该组件就是TabHost标签页中上部 或者 下部的按钮, 可以点击按钮切换选项卡;</p><p><strong>TabSpec</strong> : 代表了选项卡界面, 添加一个TabSpec即可添加到TabHost中;</p><p>– <strong>创建选项卡</strong> : newTabSpec(String tag), 创建一个选项卡;</p><p>– <strong>添加选项卡</strong> : addTab(tabSpec);</p><p>a. <strong>定义布局</strong> : 在XML文件中<strong>使用TabHost</strong>组件<strong>, 并在其中</strong>定义一个<strong>FrameLayout选项卡</strong>内容;</p><p>b. <strong>继承TabActivity</strong> : 显示选项卡组件的Activity<strong>继承TabActivity</strong>;</p><p>c. <strong>获取组件</strong> : 通过调用<strong>getTabHost()方法</strong>, 获取TabHost对象;</p><p>d. <strong>创建添加选项卡</strong> : 通过TabHost创建添加选项卡;</p><h2 id="Gallery"><a href="#Gallery" class="headerlink" title="Gallery"></a>Gallery</h2><pre><code class="xml">&lt;Gallery        android:id=&quot;@+id/mGallery&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre><blockquote><p><strong>java代码</strong></p></blockquote><pre><code class="java">package com.example.gallery;import androidx.appcompat.app.AppCompatActivity;import androidx.viewpager.widget.ViewPager;import android.content.Context;import android.media.Image;import android.os.Bundle;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.Gallery;import android.widget.ImageButton;import android.widget.ImageView;import android.widget.TextView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity {    //画廊    private Gallery mGallery;    //图片源    private List&lt;Integer&gt;mList = new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initView();    }    /**     * 初始化View     */    private void initView() {        mGallery = findViewById(R.id.mGallery);        initData();        mGallery.setAdapter(new mGalleryAdapter(this));    }    /**     * 初始化数据     */    private void initData() {        mList.add(R.drawable.img1);        mList.add(R.drawable.img2);        mList.add(R.drawable.img3);        mList.add(R.drawable.img4);    }    /**     * //Gallery的适配器     */    class mGalleryAdapter extends BaseAdapter{        //上下文        private Context mContext;        //构造方法        public mGalleryAdapter(Context mContext){            this.mContext = mContext;        }        /**         * 返回Item数量         */        @Override        public int getCount() {            if(mList != null){                return mList.size();            }            return 0;        }        /**         * 返回Item的下标         * @param position         * @return         */        @Override        public Object getItem(int position) {            return mList.get(position);        }        /**         * 下标         * @param position         * @return         */        @Override        public long getItemId(int position) {            return position;        }        @Override        public View getView(int position, View convertView, ViewGroup parent) {            ImageView iv = new ImageView(mContext);            iv.setBackgroundResource(mList.get(position));            return iv;        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android,</tag>
      
      <tag>JAVA</tag>
      
      <tag>XML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习</title>
    <link href="/2020/03/18/%E9%95%BF%E7%9F%A5%E8%AF%86/ava%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/03/18/%E9%95%BF%E7%9F%A5%E8%AF%86/ava%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>常用DOS命令:</p><pre><code class="Dos">dir :    列出当前目录下的文件以及文件夹md :   创建目录rd :     删除目录cd :    进入指定目录cd.. :  退回到上一级目录cd\:    退回到根目录del :    删除文件exit :   退出 dos 命令行</code></pre><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h2><p>类 对象</p><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性:"></a>三大特性:</h2><p>封装, 继承, 多态</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字:"></a>关键字:</h2><table><thead><tr><th><strong>用于定义数据类型的关键字</strong></th><th></th><th align="center"></th><th></th><th></th></tr></thead><tbody><tr><td>class</td><td>interface</td><td align="center">enum枚举</td><td>byte</td><td>short</td></tr><tr><td>int</td><td>long</td><td align="center">float</td><td>double</td><td>char</td></tr><tr><td>boolean</td><td>void</td><td align="center"></td><td></td><td></td></tr><tr><td><strong>用于定义数据类型值的关键字</strong></td><td></td><td align="center"></td><td></td><td></td></tr><tr><td>true</td><td>false</td><td align="center">null</td><td></td><td></td></tr><tr><td><strong>用于定义流程控制的关键字</strong></td><td></td><td align="center"></td><td></td><td></td></tr><tr><td>if</td><td>else</td><td align="center">switch</td><td>case</td><td>default</td></tr><tr><td>while</td><td>do</td><td align="center">for</td><td>break</td><td>continue</td></tr><tr><td>return</td><td></td><td align="center"></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>用于定义访问权限修饰符的关键字</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>private</td><td>protected</td><td>public</td><td>default</td><td></td></tr><tr><td>类内部可访问</td><td>类内部\同一个包\子类</td><td>任何地方</td><td>类内部和同一个包</td><td></td></tr><tr><td><strong>用于定义类，函数，变量修饰符的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>abstract抽象类</td><td>final</td><td>static(下文关键词static)</td><td>synchronized</td><td></td></tr><tr><td><strong>用于定义类与类之间关系的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>extends</td><td>implements</td><td></td><td></td><td></td></tr><tr><td>继承父类</td><td>实现接口</td><td></td><td></td><td></td></tr><tr><td><strong>用于定义建立实例及引用实例，判断实例的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>new</td><td>this</td><td>super</td><td>instanceof  对象是否是特定类的</td><td></td></tr><tr><td><strong>用于异常处理的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>try</td><td>catch</td><td>finally</td><td>throw  语句抛出异常</td><td>throws  方法抛出异常</td></tr><tr><td><strong>用于包的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>package</td><td>import</td><td></td><td></td><td></td></tr><tr><td><strong>其他修饰符关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>native</td><td>strictfp</td><td>transient</td><td>volatile</td><td>assert</td></tr></tbody></table><h2 id="Java保留字："><a href="#Java保留字：" class="headerlink" title="Java保留字："></a>Java保留字：</h2><p>现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标记符时要避免使用这些保留字<br> byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范:"></a>命名规范:</h2><p>包名: 所有字母都小写 xxxyyyzzz</p><hr><p>类名\接口名: 多单词时, 所有单词首字母大写 XxxYyyZzz</p><hr><p>变量名\方法名: 多单词, 从第二个单词开始每个单词首字母大写 xxxYyyZzz</p><hr><p>常量名: 所有单词都大学, 多单词用下划线连接 XXX_YYY_ZZZ</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型:"></a>数据类型:</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型:"></a>基本数据类型:</h3><p>→从小到大</p><blockquote><p>数值型:  </p></blockquote><p>整数类型:byte, short, int, long(+L)</p><blockquote><p>浮点类型:  </p></blockquote><p>float, double</p><blockquote><p>字符型:  </p></blockquote><p> char</p><blockquote><p>布尔型:   </p></blockquote><p>boolean</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型:"></a>引用数据类型:</h3><blockquote><p>类:  </p></blockquote><p> class</p><blockquote><p>接口:  </p></blockquote><p> interface</p><blockquote><p>数组:   </p></blockquote><p>[ ]</p><blockquote><p>字符串:  </p></blockquote><p> String</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>&amp;&amp;和|| 左边为假则右边不参与运算</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符:"></a>三元运算符:</h2><p><strong>(条件表达式)? 表达式1：表达式2；</strong></p><p><strong>括号中为true，</strong>运算后的结果是表达式1；</p><p><strong>括号中为false，</strong>运算后的结果是表达式2；</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><blockquote><p>break:  </p></blockquote><p> 结束当前循环| 用于switch和循环, 终止本层循环</p><blockquote><p>continue:  </p></blockquote><p> 跳过某个循环语句块的一次执行| 循环语句, 终止本次循环</p><blockquote><p>return:  </p></blockquote><p> 结束整个方法</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组一旦初始化, 长度不可变</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Field=属性=成员变量</p><p>Method=方法=函数</p><blockquote><p>变量:</p></blockquote><blockquote><blockquote><p>成员变量:</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>实例变量:</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>类变量: static修饰( 一个类的所有实例共享数据)</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>局部变量:</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>形参:</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>方法局部变量</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>代码块局部变量:</p></blockquote></blockquote></blockquote><h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><p>*<em>重载(overload): *</em></p><p>一个以上同名的方法, 参数个数和参数类型不同, 包括顺序不同</p><p>*<em>override: *</em></p><p>对父变量方法的重写, 有以下要求:</p><p>Ø 重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。</p><p>Ø 重写方法不能使用比被重写方法更严格的访问权限。</p><p>Ø 重写和被重写的方法须同时为static的，或同时为非static的</p><p>Ø 子类方法抛出的异常不能大于父类被重写方法的异常</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数:"></a>可变参数:</h2><pre><code class="java">//下面采用数组形参来定义方法public static void test(int a ,String[] books);//以可变个数形参来定义方法public static void test(int a ,String…books);</code></pre><p>1.可变参数：方法参数部分指定类型的参数个数是可变多个</p><p>2.声明方式：方法名（参数的类型名…参数名）</p><p>3.可变参数方法的使用与方法参数部分使用数组是一致的</p><p>4.方法的参数部分有可变形参，需要放在<code>形参声明的最后</code></p><h2 id="方法的参数传递"><a href="#方法的参数传递" class="headerlink" title="方法的参数传递:"></a>方法的参数传递:</h2><p><strong>基本数据类型:</strong> 实参的值复制给形参</p><p><strong>对象:</strong> 传递的时引用对象的堆内存中的地址</p><p>基本数据类型保存在栈内存</p><p>引用对象在栈内存保存引用对象的地址</p><p><img src="/images/image-20200318200933232.png" srcset="/img/loading.gif" alt="image-20200318200933232"></p><h2 id="JAVA包"><a href="#JAVA包" class="headerlink" title="JAVA包"></a>JAVA包</h2><p><strong>1.</strong>  <strong>java.lang—-</strong>包含一些Java语言的核心类，如String、Math、Integer、 </p><p>​               System和Thread，提供常用功能。不需显示声明</p><p><strong>2.  java.net—-</strong>包含执行与网络相关的操作的类和接口。</p><p><strong>3. java.io  —-</strong>包含能提供多种输入/输出功能的类。</p><p><strong>4. java.util—-</strong>包含一些实用工具类，如定义系统特性、接口的集合框架类、</p><p>​              使用与日期日历相关的函数。</p><p><strong>5.  java.text—-</strong>包含了一些java格式化相关的类</p><p><strong>6. java.sql—-</strong>包含了java进行JDBC数据库编程的相关类/接口</p><p><strong>7. java.awt—-</strong>包含了构成抽象窗口工具集（abstract window toolkits）的</p><p>​               多个类，这些类被用来构建和管理应用程序的图形用户界 </p><p>​               面(GUI)。</p><p><strong>8. java.applet—-</strong>包含applet运行所需的一些类。</p><h2 id="封装和隐藏"><a href="#封装和隐藏" class="headerlink" title="封装和隐藏:"></a>封装和隐藏:</h2><blockquote><p>Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p></blockquote><ul><li><p>隐藏一个类中不需要对外提供的实现细节；</p></li><li><p>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；</p></li><li><p>便于修改，增强代码的可维护性；</p></li></ul><h2 id="构造器-构造方法"><a href="#构造器-构造方法" class="headerlink" title="构造器(构造方法):"></a>构造器(构造方法):</h2><ul><li><p>与类名称相同, 不声明返回值类型</p></li><li><p>不能被static, final, synchronized, abstract 和 native修饰, 不能有return语句返回值</p></li></ul><p><strong>构造器作用:</strong> 创建对象\给对象进行初始化;</p><h2 id="this"><a href="#this" class="headerlink" title="this:"></a>this:</h2><blockquote><p>在java中，this关键字比较难理解，它的作用和其词义很接近。</p></blockquote><ul><li><p>它在方法内部使用，即这个方法所属对象的引用；</p></li><li><p>它在构造器内部使用，表示该构造器正在初始化的对象。</p></li></ul><blockquote><p>this表示当前对象，可以调用类的属性、方法和构造器</p></blockquote><ul><li>当在方法内需要用到调用该方法的对象时，就用this。</li></ul><blockquote><p>使用this调用本类的构造器</p></blockquote><pre><code class="java">class Person{                        //定义person类    private String name;    private int age;    public Person(){                //无参构造        System.out.pringln(&quot;新对象实例化&quot;)    }    public Person(String name){        this();                        //调用本类中的无参构造        this.name = name;    }    public Person(String name, int age){        this(name);                    //调用有一个参数的构造方法        this.age = age;    }    public String getInfo(){        return &quot;姓名:&quot; +name + &quot;年龄:&quot; + agel    }}</code></pre><ul><li><p>1.使用this()必须放在构造器的首行！</p></li><li><p>2.使用this调用本类中其他的构造器，保证至少有一个构造器是不用this的。（实际上就是不能出现构造器自己调用自己）</p><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2></li><li><p>类是公共的</p></li><li><p>有一个无参的公共的构造器</p></li><li><p>有属性，属性一般是私有的，且有对应的get、set方法</p></li></ul><h2 id="调用父类的构造器"><a href="#调用父类的构造器" class="headerlink" title="调用父类的构造器"></a>调用父类的构造器</h2><ul><li><p>子类中所有的构造器默认都会访问父类中空参数的构造器</p></li><li><p>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行</p></li><li><p><code>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</code></p></li></ul><h2 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h2><table><thead><tr><th align="center"><strong>区别点</strong></th><th><strong>this</strong></th><th><strong>super</strong></th></tr></thead><tbody><tr><td align="center">访问属性</td><td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td><td>访问父类中的属性</td></tr><tr><td align="center">调用方法</td><td>访问本类中的方法</td><td>直接访问父类中的方法</td></tr><tr><td align="center">调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr><tr><td align="center">特殊</td><td>表示当前对象</td><td>无此概念</td></tr></tbody></table><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性:"></a>多态性:</h2><p>子类的对象可以替代父类的对象使用:</p><pre><code class="java">Person p = new Person();Person e = new Student(); // Person类型的变量e，指向Student类型的对象</code></pre><ul><li><p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。</p></li><li><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</p></li></ul><p><strong>多态小结:</strong></p><p>l <strong>前提：</strong></p><p>需要存在继承或者实现关系</p><p>要有覆盖操作</p><p>l <strong>成员方法：</strong></p><p>编译时：要查看引用变量所属的类中是否有所调用的方法。</p><p>运行时：调用实际对象所属的类中的重写方法。</p><p>l <strong>成员变量：</strong></p><p>不具备多态性，只看引用变量所属的类。</p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object是所有类的父类</p><blockquote><p>Object类中的主要方法</p></blockquote><table><thead><tr><th>**方法名称</th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>public Object()</td><td>构造</td><td>构造方法</td></tr><tr><td>public boolean equals(Object obj)</td><td>普通</td><td>对象比较</td></tr><tr><td>public int hashCode()</td><td>普通</td><td>取得Hash码</td></tr><tr><td>public String toString()</td><td>普通</td><td>对象打印时调用</td></tr></tbody></table><h2 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h2><p>l <strong>基本数据类型的Casting：</strong></p><p><strong>自动类型转换</strong>：小的数据类型可以自动转换成大的数据类型</p><p>​       如long g=20;      double d=12.0f</p><p><strong>强制类型转换：</strong>可以把大的数据类型强制转换(casting)成小的数据类型</p><p>​      如 float f=(float)12.0;  int a=(int)1200L</p><p>l <strong>对Java对象的强制类型转换称为造型</strong></p><ul><li><p>从子类到父类的类型转换可以自动进行</p></li><li><p>从父类到子类的类型转换必须通过造型(强制类型转换)实现</p></li><li><p>无继承关系的引用类型间的转换是非法的</p></li></ul><h2 id="和-equals"><a href="#和-equals" class="headerlink" title="== 和 equals:"></a>== 和 equals:</h2><h3 id=""><a href="#" class="headerlink" title="==:"></a>==:</h3><p>基本类型比较值:只要两个变量的值相等，即为true.</p><pre><code class="java">int a=5; if(a==6){…}</code></pre><p>引用类型比较引用(是否指向同一个对象):只有指向同一个对象时，==才返回true.</p><pre><code class="java">Person p1=new Person();Person p2=new Person();if (p1==p2){…}</code></pre><p>用“==”进行比较时，符号两边的<strong>数据类型必须兼容</strong>(可自动转换的基本数据类型除外)，否则编译出错；</p><h3 id="Equals"><a href="#Equals" class="headerlink" title="Equals:"></a>Equals:</h3><blockquote><p>equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写.  </p></blockquote><ul><li><p>只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象.</p></li><li><p>格式:obj1.equals(obj2)</p></li></ul><blockquote><p> 特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象;</p></blockquote><ul><li>原因：在这些类中重写了Object类的equals()方法.</li></ul><h2 id="包装类-Wrapper"><a href="#包装类-Wrapper" class="headerlink" title="包装类(Wrapper):"></a>包装类(Wrapper):</h2><table><thead><tr><th><strong>基本数据类型</strong></th><th><strong>包装类</strong></th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><blockquote><p><strong>包装类装箱:</strong></p></blockquote><blockquote><blockquote><p>基本数据类型包装成包装类的实例:</p></blockquote></blockquote><ul><li><p><strong>通过包装类的构造器实现：</strong></p><pre><code>int i = 500;  Integer t = new Integer(i);</code></pre></li><li><p><strong>还可以通过字符串参数构造包装类对象：</strong></p><pre><code class="java">Float f = new Float(“4.56”);Long l = new Long(“asdf”); //NumberFormatException</code></pre></li></ul><blockquote><p><strong>包装类拆箱:</strong></p></blockquote><blockquote><blockquote><p>获得包装类对象中包装的基本类型变量调用包装类的.xxxValue()方法：</p></blockquote></blockquote><pre><code class="java">boolean b = bObj.booleanValue();      </code></pre><blockquote><p><strong>字符串转换成基本数据类型</strong></p></blockquote><blockquote><blockquote><p>通过包装类的构造器实现：         </p></blockquote></blockquote><pre><code class="java">int i = new Integer(“12”);</code></pre><blockquote><blockquote><p>通过包装类的parseXxx(String s)静态方法：         </p></blockquote></blockquote><pre><code class="java">Float f = Float.parseFloat(“12.1”);</code></pre><blockquote><p><strong>基本数据类型转换成字符串</strong></p></blockquote><blockquote><blockquote><p>调用字符串重载的valueOf()方法：</p></blockquote></blockquote><pre><code class="java">String fstr = String.valueOf(2.34f);</code></pre><blockquote><blockquote><p>更直接的方式：</p></blockquote></blockquote><pre><code class="java">String intStr = 5 + “”</code></pre><blockquote><p><strong>包装类用法举例:</strong>         </p></blockquote><pre><code class="java">int i = 500;Integer t = new Integer(i);</code></pre><ul><li><strong>装箱：包装类使得一个基本数据类型的数据变成了类。</strong></li></ul><p><strong>有了类的特点，可以调用类中的方法。</strong></p><pre><code class="java">String s = t.toString(); // s = “500“,t是类，有toString方法String s1 = Integer.toString(314); // s1= “314“ 将数字转换成字符串。String s2=“4.56”;double ds=Double.parseDouble(s2);  //将字符串转换成数字</code></pre><ul><li><p><strong>拆箱：将数字包装类中内容变为基本数据类型。</strong></p><pre><code class="java">int j = t.intValue();  // j = 500，intValue取出包装类中的数据</code></pre></li><li><p>包装类在实际开发中用的最多的在于字符串变为基本数据类型。</p></li></ul><pre><code>String str1 = &quot;30&quot; ;String str2 = &quot;30.3&quot; ; int x = Integer.parseInt(str1) ; // 将字符串变为int型float f = Float.parseFloat(str2) ; // 将字符串变为int型</code></pre><h2 id="static关键词"><a href="#static关键词" class="headerlink" title="static关键词:"></a>static关键词:</h2><p>可修饰属性, 方法, 代码块, 内部类</p><blockquote><p><strong>特点:</strong> </p></blockquote><ul><li><p>随着类的加载而加载</p></li><li><p>优先于对象存在</p></li><li><p>修饰的成员，被所有对象所共享</p></li><li><p>访问权限允许时，可不创建对象，直接被类调用</p></li></ul><blockquote><p><strong>类方法:</strong> </p></blockquote><ul><li><p>没有对象的实例时，可以用类名.方法名()的形式访问由static标记的类方法。</p></li><li><p>在static方法内部只能访问类的static属性，不能访问类的非static属性</p></li><li><p>因为不需要实例就可以访问static方法，因此static方法内部不能有this,也不能有super</p></li><li><p>重载的方法需要同时为static的或者非static的.</p></li></ul><h2 id="单例设计"><a href="#单例设计" class="headerlink" title="单例设计"></a>单例设计</h2><ul><li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造方法的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</li></ul><blockquote><p>懒汉:请求后创建对象实例 (存在线程安全问题)**</p></blockquote><pre><code class="java">class Singleton{    //1.将构造器私有化，保证在此类的外部，不能调用本类的构造器。    private Singleton(){    }    //2.先声明类的引用    //4.也需要配合static的方法，用static修饰此类的引用。    private static Singleton  instance = null;    //3.设置公共的方法来访问类的实例    public static Singleton  getInstance(){    //3.1如果类的实例未创建，那些先要创建，然后返回给调用者：本类。因此，需要static 修饰。        if(instance == null){            instance = new Singleton();        }    //3.2 若有了类的实例，直接返回给调用者。        return instance;    }  }</code></pre><blockquote><p><strong>饿汉:先创建好</strong></p></blockquote><pre><code class="java">class Single{     //private的构造器，不能在类的外部创建该类的对象     private Single() {}      //私有的，只能在类的内部访问     private static Single onlyone = new Single();     //getSingle()为static，不用创建对象即可访问     public static Single getSingle() {        return onlyone;     }} public class TestSingle{    public static void main(String args[]) {                Single  s1 = Single.getSingle();      //访问静态方法        Single  s2 = Single.getSingle();        if (s1==s2){            System.out.println(&quot;s1 is equals to s2!&quot;);        }}}</code></pre>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python中正则表达式的使用</title>
    <link href="/2020/02/23/%E9%95%BF%E7%9F%A5%E8%AF%86/ython%E4%B8%AD%E6%94%BF%E7%AD%96%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/23/%E9%95%BF%E7%9F%A5%E8%AF%86/ython%E4%B8%AD%E6%94%BF%E7%AD%96%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p> 正则表达式是一个特殊的字符序列，能方便的检查一个字符串是否与某种模式匹配。re模块使得python拥有全部的正则表达式功能。</p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>通过使用正则表达式，可以：<br>测试字符串内的模式。<br>—— 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为<strong>数据验证</strong>。<br><strong>替换文本</strong>。—— 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。<br>基于模式匹配从字符串中提取子字符串。—— 可以查找文档内或输入域内特定的文本。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><pre><code>&#39;.&#39;     匹配所有字符串，除\n以外&#39;-&#39;     表示范围[0-9]&#39;*&#39;     匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。&#39;+&#39;     匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+&#39;^&#39;     匹配字符串开头&#39;$&#39;     匹配字符串结尾 re&#39;\&#39;     转义字符， 使后一个字符改变原来的意思，如果字符串中有字符*需要匹配，可以\*或者字符集[*] re.findall(r&#39;3\*&#39;,&#39;3*ds&#39;)结[&#39;3*&#39;]&#39;*&#39;     匹配前面的字符0次或多次 re.findall(&quot;ab*&quot;,&quot;cabc3abcbbac&quot;)结果：[&#39;ab&#39;, &#39;ab&#39;, &#39;a&#39;]&#39;?&#39;     匹配前一个字符串0次或1次 re.findall(&#39;ab?&#39;,&#39;abcabcabcadf&#39;)结果[&#39;ab&#39;, &#39;ab&#39;, &#39;ab&#39;, &#39;a&#39;]&#39;{m}&#39;   匹配前一个字符m次 re.findall(&#39;cb{1}&#39;,&#39;bchbchcbfbcbb&#39;)结果[&#39;cb&#39;, &#39;cb&#39;]&#39;{n,m}&#39; 匹配前一个字符n到m次 re.findall(&#39;cb{2,3}&#39;,&#39;bchbchcbfbcbb&#39;)结果[&#39;cbb&#39;]&#39;\d&#39;    匹配数字，等于[0-9] re.findall(&#39;\d&#39;,&#39;电话:10086&#39;)结果[&#39;1&#39;, &#39;0&#39;, &#39;0&#39;, &#39;8&#39;, &#39;6&#39;]&#39;\D&#39;    匹配非数字，等于[^0-9] re.findall(&#39;\D&#39;,&#39;电话:10086&#39;)结果[&#39;电&#39;, &#39;话&#39;, &#39;:&#39;]&#39;\w&#39;    匹配字母和数字，等于[A-Za-z0-9] re.findall(&#39;\w&#39;,&#39;alex123,./;;;&#39;)结果[&#39;a&#39;, &#39;l&#39;, &#39;e&#39;, &#39;x&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;]&#39;\W&#39;    匹配非英文字母和数字,等于[^A-Za-z0-9] re.findall(&#39;\W&#39;,&#39;alex123,./;;;&#39;)结果[&#39;,&#39;, &#39;.&#39;, &#39;/&#39;, &#39;;&#39;, &#39;;&#39;, &#39;;&#39;]&#39;\s&#39;    匹配空白字符 re.findall(&#39;\s&#39;,&#39;3*ds \t\n&#39;)结果[&#39; &#39;, &#39;\t&#39;, &#39;\n&#39;]&#39;\S&#39;    匹配非空白字符 re.findall(&#39;\s&#39;,&#39;3*ds \t\n&#39;)结果[&#39;3&#39;, &#39;*&#39;, &#39;d&#39;, &#39;s&#39;]&#39;\A&#39;    匹配字符串开头&#39;\Z&#39;    匹配字符串结尾&#39;\b&#39;    匹配单词的词首和词尾，单词被定义为一个字母数字序列，因此词尾是用空白符或非字母数字符来表示的&#39;\B&#39;    与\b相反，只在当前位置不在单词边界时匹配[]      是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示相应位置的字符要匹配英文字符和数字。[\s*]表示空格或者*号&#39;(?P&lt;name&gt;...)&#39;  分组，除了原有编号外在指定一个额外的别名 re.search(&quot;(?P&lt;province&gt;[0-9]{4})(?P&lt;city&gt;[0-9]{2})(?P&lt;birthday&gt;[0-9]{8})&quot;,&quot;371481199306143242&quot;).groupdict(&quot;city&quot;) 结果{&#39;province&#39;: &#39;3714&#39;, &#39;city&#39;: &#39;81&#39;, &#39;birthday&#39;: &#39;19930614&#39;}</code></pre><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p><strong>贪婪模式和非贪婪模式</strong></p><p>正则表达式通常使用于查找匹配字符串。python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符；非贪婪模式正好相反，总是尝试匹配尽可能少的字符。<br><strong>使用方法</strong></p><p>在python中默认采用的是贪婪模式，使用非贪婪模式的话，只需要在量词后面直接加上一个问号”?”。</p><p>例子当中已经匹配到了“ab”时已经可以使整个表达式匹配成功，但是由于采用的是贪婪模式，所以还需要往后继续匹配，一直到匹配到最后一个”b”的时候，后面已经没有可以成功匹配的字符串了，匹配结束。返回匹配结果“abbbbbb”。 所以，我们可以将贪婪模式理解为：在整个表达式匹配成功的前提下，尽可能多的匹配。</p><p>非贪婪模式也就是将我们例子中的正则表达式“ab+”改为”ab+?”，当匹配到“ab”时，已经匹配成功，直接结束匹配，不在向后继续尝试，返回匹配成功的字符串”ab”。<br>所以，我们可以将非贪婪模式理解为：在整个表达式匹配成功的前提下，尽可能少的匹配</p><pre><code>import reexample = &quot;&lt;div&gt;test1&lt;/div&gt;&lt;div&gt;test2&lt;/div&gt;&quot;greedPattern = re.compile(&quot;&lt;div&gt;.*&lt;/div&gt;&quot;)notGreedPattern = re.compile(&quot;&lt;div&gt;.*?&lt;/div&gt;&quot;)greedResult = greedPattern.search(example)notGreedResult = notGreedPattern.search(example)print(&quot;greedResult = %s&quot; % greedResult.group())print(&quot;notGreedResult = %s&quot; % notGreedResult.group())[python@master test]$ python3 a.py greedResult = &lt;div&gt;test1&lt;/div&gt;&lt;div&gt;test2&lt;/div&gt;notGreedResult = &lt;div&gt;test1&lt;/div&gt;</code></pre><p>能达到同样匹配结果的贪婪与非贪婪模式，通常是贪婪模式的匹配效率较高。 所有的非贪婪模式，都可以通过修改量词修饰的子表达式，转换为贪婪模式。 贪婪模式可以与固化分组结合，提升匹配效率，而非贪婪模式却不可以。</p><h1 id="使用re模块"><a href="#使用re模块" class="headerlink" title="使用re模块"></a>使用re模块</h1><p><strong>反斜杠的困扰</strong></p><p>在 python 的字符串中，\ 是被当做转义字符的。在正则表达式中，\ 也是被当做转义字符。这就导致了一个问题：如果你要匹配 \ 字符串，那么传递给 re.compile() 的字符串必须是”\\“。</p><p>由于字符串的转义，所以实际传递给 re.compile() 的是”\“，然后再通过正则表达式的转义，”\“ 会匹配到字符”&quot;。这样虽然可以正确匹配到字符 \，但是很麻烦，而且容易漏写反斜杠而导致 Bug。那么有什么好的解决方案呢？</p><p>原始字符串很好的解决了这个问题，通过在字符串前面添加一个r，表示原始字符串，不让字符串的反斜杠发生转义。那么就可以使用r”\“来匹配字符\了。  </p><h2 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile()"></a><strong>re.compile()</strong></h2><p>编译正则表达式模式，返回一个对象。可以把常用的正则表达式编译成正则表达式对象，方便后续调用及提高效率。<br><strong>re.compile(pattern,flags=0)</strong><br><strong>pattern</strong>指定编译时的表达式字符串<br><strong>flags</strong>编译标志位，用来修改正则表达式的匹配方式。支持 re.L|re.M 同时匹配</p><p><strong>flags 标志位参数</strong><br>re.I(re.IGNORECASE)　　　使匹配对大小写不敏感<br>re.L(re.LOCAL)　　　　　　做本地化识别(locale-aware)匹配<br>re.M(re.MULTILINE)　　　　多行匹配，影响 ^ 和 $<br>re.S(re.DOTALL)　　　　　　使 . 匹配包括换行在内的所有字符<br>re.U(re.UNICODE)　　　　　根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.<br>re.X(re.VERBOSE)　　　　　该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</p><pre><code class="python">import recontent = &#39;Citizen wang , always fall in love with neighbour，WANG&#39;rr = re.compile(r&#39;wan\w&#39;, re.I) # 不区分大小写print(type(rr))a = rr.findall(content)print(type(a))print(a)[python@master test]$ python3 b.py &lt;class &#39;re.Pattern&#39;&gt;&lt;class &#39;list&#39;&gt;[&#39;wang&#39;, &#39;WANG&#39;]</code></pre><h2 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h2><p>尝试从一个字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，则返回None。</p><p><strong>re.match(pattern, string, flags=0)</strong></p><p><code>pattern</code>: 待匹配的正则表达式<br><code>string</code>: 待查找的字符串<br><code>flags（可选参数）</code>: 标志位，控制正则表达式的匹配方式。re.I(ignore) re.L(local) re.M(many lines) re.S(sum) re.U(unicode) re.X<br><code>返回值</code>：匹配成功返回匹配对象（group(num=0) / groups() 返回的是一个元组），匹配失败返回None</p><p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式</p><p>group(num=0)匹配的整个表达式的字符串<br>group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</p><p>groups() 返回一个包含所有小组字符串的元组，从 1 到所含的小组号。</p><p>例子1：</p><pre><code class="python"># -*- coding: UTF-8 -*-import reprint(re.match(&#39;www&#39;, &#39;www.runoob.com&#39;).span())  # 在起始位置匹配print(re.match(&#39;com&#39;, &#39;www.runoob.com&#39;))         # 不在起始位置匹配[python@master test]$ python3 d.py (0, 3)None</code></pre><p>例子二：</p><pre><code class="python">[python@master test]$ more c.py import reline = &quot;Cats are Smarter than dogs&quot;# re.M：多行匹配# re.I:忽略大小写进行匹配# match()以元组形式返回匹配成功的对象match_obj = re.match(r&quot;(.*) are (.*?) .*&quot;, line, re.M | re.I)if match_obj:    print(&quot;match_obj.group(): &quot;, match_obj.group())    print(&quot;match_obj.group(1): &quot;, match_obj.group(1))    print(&quot;match_obj.group(2): &quot;, match_obj.group(2))    print(&quot;match_obj.group(3): &quot;, match_obj.group(1,2))    print(&quot;match_obj.groups(): &quot;, match_obj.groups())else:    print(&quot;None match!&quot;)print(&quot;*&quot; * 98)[python@master test]$ python3 c.py match_obj.group():  Cats are Smarter than dogsmatch_obj.group(1):  Catsmatch_obj.group(2):  Smartermatch_obj.group(3):  (&#39;Cats&#39;, &#39;Smarter&#39;)match_obj.groups():  (&#39;Cats&#39;, &#39;Smarter&#39;)</code></pre><h2 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h2><p>扫描整个字符串并返回第一个成功的匹配。<br>函数语法：<br><strong>re.search(pattern, string, flags=0)</strong><br>函数参数说明：<br><code>pattern</code>      匹配的正则表达式<br><code>string</code>          要匹配的字符串。<br><code>flags</code>            标志位，用于控制正则表达式  的匹配方式，如：是否区分大小写，多行匹配等等。</p><p>匹配成功re.search方法返回一个匹配的对象，否则返回None。<br>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。<br>group(num=0)匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。<br>groups()返回一个包含所有小组字符串的元组，从1到所含的小组号。</p><p>例子1：</p><pre><code class="python">[python@master test]$ more a.py # -*- coding: UTF-8 -*- import reprint(re.search(&#39;www&#39;, &#39;www.runoob.com&#39;).span())  # 在起始位置匹配print(re.search(&#39;com&#39;, &#39;www.runoob.com&#39;).span())         # 不在起始位置匹配[python@master test]$ python3 a.py (0, 3)(11, 14)</code></pre><p>例子2：</p><pre><code class="python">[python@master test]$ more b.py import reline = &quot;Cats are smarter than dogs&quot;;searchObj = re.search( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I)if searchObj:   print(&quot;searchObj.group() : &quot;, searchObj.group())   print(&quot;searchObj.group(1) : &quot;, searchObj.group(1))   print(&quot;searchObj.group(2) : &quot;, searchObj.group(2))else:   print(&quot;Nothing found!!&quot;)[python@master test]$ python3 b.py searchObj.group() :  Cats are smarter than dogssearchObj.group(1) :  CatssearchObj.group(2) :  smarter</code></pre><h2 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h2><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；<br>而re.search匹配整个字符串，直到找到一个匹配。</p><pre><code class="python">[python@master test]$ more c.py import reline = &quot;Cats are smarter than dogs&quot;;matchObj = re.match( r&#39;dogs&#39;, line, re.M|re.I)if matchObj:   print(&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())else:   print(&quot;No match!!&quot;)matchObj = re.search( r&#39;dogs&#39;, line, re.M|re.I)if matchObj:   print(&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())else:   print(&quot;No match!!&quot;)[python@master test]$ python3 c.py No match!!search --&gt; matchObj.group() :  dogs</code></pre><h2 id="re-sub"><a href="#re-sub" class="headerlink" title="re.sub()"></a>re.sub()</h2><p>Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。<br>语法：<br><strong>re.sub(pattern, repl, string, count=0, flags=0)</strong><br>参数：<br><code>pattern</code>       正则中的模式字符串。<br><code>repl</code>            替换的字符串，也可为一个函数。<br><code>string</code>         要被查找替换的原始字符串。<br><code>count</code>         模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</p><pre><code class="python">[python@master test]$ more d.pyimport rephone = &quot;2004-959-559 # 这是一个电话号码&quot;# 删除注释num = re.sub(r&#39;#.*$&#39;, &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num)# 移除非数字的内容num = re.sub(r&#39;\D&#39;, &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num)[python@master test]$ python3 d.py 电话号码 :  2004-959-559 电话号码 :  2004959559</code></pre><p><strong>repl 参数是一个函数</strong></p><p>以下实例中将字符串中的匹配的数字乘于 2</p><pre><code class="python">[python@master test]$ more e.py import re# 将匹配的数字乘于 2def double(matched):    value = int(matched.group(&#39;value&#39;))    return str(value * 2)s = &#39;A23G4HFD567&#39;print(re.sub(&#39;(?P&lt;value&gt;\d+)&#39;, double, s))[python@master test]$ python3 e.py A46G8HFD1134</code></pre><h2 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h2><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。<br>注意： match 和 search 是匹配一次 findall 匹配所有。<br>语法格式为：<br><strong>findall(string[, pos[, endpos]])</strong><br>参数：<br><code>string</code>          待匹配的字符串。<br><code>pos</code>              可选参数，指定字符串的起始位置，默认为 0。<br><code>endpos</code>           可选参数，指定字符串的结束位置，默认为字符串的长度。    </p><p>查找字符串中的所有数字：</p><pre><code class="python">[python@master test]$ more a.py import repattern = re.compile(r&#39;\d+&#39;)   # 查找数字result1 = pattern.findall(&#39;runoob 123 google 456&#39;)result2 = pattern.findall(&#39;run88oob123google456&#39;, 0, 10)print(result1)print(result2)[python@master test]$ python3 a.py [&#39;123&#39;, &#39;456&#39;][&#39;88&#39;, &#39;12&#39;]</code></pre><h2 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer()"></a>re.finditer()</h2><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。<br><strong>re.finditer(pattern, string, flags=0)</strong><br>参数：<br><code>pattern</code>         匹配的正则表达式<br><code>string</code>         要匹配的字符串。<br><code>flags</code>           标志位，用于控制正则表达式的  匹配方式，如：是否区分大小写，多行匹配等等。</p><pre><code class="python">[python@master test]$ more d.py import reit = re.finditer(r&quot;\d+&quot;,&quot;12a32bc43jf3&quot;) for match in it:     print (match.group() )[python@master test]$ python3 d.py 1232433</code></pre><h2 id="re-split"><a href="#re-split" class="headerlink" title="re.split()"></a>re.split()</h2><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：<br><strong>re.split(pattern, string[, maxsplit=0, flags=0])</strong><br>参数：<br><code>pattern</code>           匹配的正则表达式<br><code>string</code>           要匹配的字符串。<br><code>maxsplit</code>         分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。<br><code>flags</code>             标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等  </p><pre><code class="python">&gt;&gt;&gt; re.split(&#39;\W+&#39;,&#39;runoob,runoob,runoob.&#39;)[&#39;runoob&#39;, &#39;runoob&#39;, &#39;runoob&#39;, &#39;&#39;]&gt;&gt;&gt; re.split(&#39;(\W+)&#39;,&#39; runoob,runoob,runoob.&#39;) [&#39;&#39;, &#39; &#39;, &#39;runoob&#39;, &#39;,&#39;, &#39;runoob&#39;, &#39;,&#39;, &#39;runoob&#39;, &#39;.&#39;, &#39;&#39;]&gt;&gt;&gt; re.split(&#39;\W+&#39;, &#39; runoob, runoob, runoob.&#39;, 1) [&#39;&#39;, &#39;runoob, runoob, runoob.&#39;]&gt;&gt;&gt; re.split(&#39;a&#39;, &#39;hello world&#39;)[&#39;hello world&#39;]# 对于一个找不到匹配的字符串而言，split 不会对其作出分割</code></pre><h1 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h1><p><strong>re.RegexObject</strong><br>re.compile() 返回 RegexObject 对象。<br><strong>re.MatchObject</strong><br>   group() 返回被 RE 匹配的字符串。<br>   start() 返回匹配开始的位置<br>   end()   返回匹配结束的位置<br>   span()  返回一个元组包含匹配 (开始,结束) 的位置     </p><h1 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h1><p>模式字符串使用特殊的语法来表示一个正则表达式：<br>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。<br>多数字母和数字前加一个反斜杠时会拥有不同的含义。<br>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。<br>反斜杠本身需要使用反斜杠转义。<br>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\t’，等价于 \t )匹配相应的特殊字符。<br>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p><pre><code>^                 匹配字符串的开头$                 匹配字符串的末尾。.                 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。[...]             用来表示一组字符,单独列出：[amk] 匹配 &#39;a&#39;，&#39;m&#39;或&#39;k&#39;[^...]            不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。re*               匹配0个或多个的表达式。re+               匹配1个或多个的表达式。re?               匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式re{ n}            匹配n个前面表达式。例如，&quot;o{2}&quot;不能匹配&quot;Bob&quot;中的&quot;o&quot;，但是能匹配&quot;food&quot;中的两个o。re{ n,}           精确匹配n个前面表达式。例如，&quot;o{2,}&quot;不能匹配&quot;Bob&quot;中的&quot;o&quot;，但能匹配&quot;foooood&quot;中的所有o。&quot;o{1,}&quot;等价于&quot;o+&quot;。&quot;o{0,}&quot;则等价于&quot;o*&quot;。re{ n, m}         匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式a| b              匹配a或b(re)              匹配括号内的表达式，也表示一个组(?imx)            正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。(?-imx)           正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。(?: re)           类似 (...), 但是不表示一个组(?imx: re)        在括号中使用i, m, 或 x 可选标志(?-imx: re)       在括号中不使用i, m, 或 x 可选标志(?#...)           注释.(?= re)           前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。(?! re)           前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。(?&gt; re)           匹配的独立模式，省去回溯。\w                匹配数字字母下划线\W                匹配非数字字母下划线\s                匹配任意空白字符，等价于 [\t\n\r\f]。\S                匹配任意非空字符\d                匹配任意数字，等价于 [0-9]。\D                匹配任意非数字\A                匹配字符串开始\Z                匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。\z                匹配字符串结束\G                匹配最后匹配完成的位置。\b                匹配一个单词边界，也就是指单词和空格间的位置。例如， &#39;er\b&#39; 可以匹配&quot;never&quot; 中的 &#39;er&#39;，但不能匹配 &quot;verb&quot; 中的 &#39;er&#39;。\B                匹配非单词边界。&#39;er\B&#39; 能匹配 &quot;verb&quot; 中的 &#39;er&#39;，但不能匹配 &quot;never&quot; 中的 &#39;er&#39;。\n, \t, 等。       匹配一个换行符。匹配一个制表符, 等\1...\9           匹配第n个分组的内容。\10               匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</code></pre><h1 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h1><pre><code>[Pp]ython           匹配 &quot;Python&quot; 或 &quot;python&quot;    rub[ye]               匹配 &quot;ruby&quot; 或 &quot;rube&quot;          [aeiou]               匹配中括号内的任意一个字母     [0-9]                   匹配任何数字。类似于 [0123456789][a-z]                   匹配任何小写字母                 [A-Z]                  匹配任何大写字母                 [a-zA-Z0-9]        匹配任何字母及数字         [^aeiou]              除了aeiou字母以外的所有字符  [^0-9]                 匹配除了数字外的字符</code></pre><h1 id="特殊字符类"><a href="#特殊字符类" class="headerlink" title="特殊字符类"></a>特殊字符类</h1><pre><code>.                  匹配除 &quot;\n&quot; 之外的任何单个字符。要匹配包括 &#39;\n&#39; 在内的任何字符，请使用象 &#39;[.\n]&#39; 的模式。    \d                匹配一个数字字符。等价于 [0-9]。                                                       \D                匹配一个非数字字符。等价于 [^0-9]。                                                    \s                匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。                 \S                匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                                            \w                匹配包括下划线的任何单词字符。等价于&#39;[A-Za-z0-9_]&#39;。                                   \W               匹配任何非单词字符。等价于 &#39;[^A-Za-z0-9_]&#39;。  </code></pre><blockquote><p>参考:<a href="https://www.cnblogs.com/hello-wei/p/10181055.html" target="_blank" rel="noopener">https://www.cnblogs.com/hello-wei/p/10181055.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式练习</title>
    <link href="/2020/02/23/%E9%95%BF%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0/"/>
    <url>/2020/02/23/%E9%95%BF%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>昨天学了点正则表达式，最后一个是实验课，需要写一个小爬虫，获取百度搜索关键词相应搜索页面的第一页，然后利用正则表达式选出其中的是个搜索结果的标题然后输入</p></blockquote><h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a><strong>整体思路</strong></h1><ul><li>构建GUI，一个输入文本框(获取关键词)，一个开始按钮，一个输出文本框框(输出搜索结果)</li><li>获得网页源代码，根据输入的关键词生成地址，并找到该地址的源码以便下一步使用</li><li>利用正则表达式对网页源码进行筛选，找到相应的搜索结果转换成字符串并输出</li></ul><h2 id="构建GUI"><a href="#构建GUI" class="headerlink" title="构建GUI"></a><strong>构建GUI</strong></h2><p>利用Pyqt带的Designer设计的<br><img src="/images/pasted-24.png" srcset="/img/loading.gif" alt="1"><br>上面的文本框输入文字，开始按钮，下面的大文本框输出文字</p><h2 id="网页源码爬取"><a href="#网页源码爬取" class="headerlink" title="网页源码爬取"></a><strong>网页源码爬取</strong></h2><p>一开始想用urllib进行爬取，不过好像百度有反扒机制，一开始没有加head头和后面加了head头都不行，会返回一个安全验证的页面<br><img src="/images/pasted-25.png" srcset="/img/loading.gif" alt="2"></p><pre><code class="python">import urllib.requesthead = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&#39;}url = &quot;http://www.baidu.com/s&quot;data = {    &#39;wd&#39;: &quot;nihong&quot;}data = urllib.parse.urlencode(data)  # 编码工作，由dict转成stringfull_url = url + &#39;?&#39; + data  # Get请求发送request = urllib.request.Request(url = full_url, headers = head)response = urllib.request.urlopen(request)print(response.read().decode(&#39;utf-8&#39;))</code></pre><p>后面采用的是模拟浏览器渲染的方式，selenuim进行源码的爬取，但是速度会比较慢因为涉及到浏览器的渲染  </p><h2 id="正则表达式使用"><a href="#正则表达式使用" class="headerlink" title="正则表达式使用"></a><strong>正则表达式使用</strong></h2><p>用火狐的检查和谷歌浏览器的检查貌似代码顺序会不一样<br><img src="/images/pasted-26.png" srcset="/img/loading.gif" alt="火狐浏览器"></p><blockquote><p>火狐浏览器<br><img src="/images/pasted-27.png" srcset="/img/loading.gif" alt="谷歌浏览器"><br>谷歌浏览器</p></blockquote><p>一开始没发现的时候坑了好久<br>最终的正则表达式：</p><pre><code>&lt;div\s+class=&quot;(result|result-op)\s+c-container\s+.*?&lt;a.*?&gt;(.*?)&lt;/a&gt;</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="python">from main_window import Ui_MainWindowfrom PyQt5.QtWidgets import  QMainWindow, QApplicationfrom selenium import webdriverfrom selenium.webdriver.chrome.options import  Optionsimport timeimport urllibimport reimport sysclass my_main_window(QMainWindow, Ui_MainWindow):    def __init__(self):        super(my_main_window, self).__init__()        self.setupUi(self)        self.btn_start.clicked.connect(self.read_imput_text)        self.btn_start.clicked.connect(self.get_words)    def read_imput_text(self):        input_text = self.text_inputbox.toPlainText()        #配置浏览器，关闭界面        chrome_opt = Options()        chrome_opt.add_argument(&#39;---windows-size=1366,768&#39;)        chrome_opt.add_argument(&#39;--headless&#39;)        chrome_opt.add_argument(&#39;--disable-pu&#39;)        #配置url        url = &quot;http://www.baidu.com/s&quot;        data = {&#39;wd&#39;:input_text}        full_url = url + &#39;?&#39; + urllib.parse.urlencode(data)        #获取页面源码        browser = webdriver.Chrome(options=chrome_opt)        browser.get(full_url)        time.sleep(2)        self.page = browser.page_source        print(self.page)        browser.quit()    def get_words(self):        #正则表达式，提取关键词        pattern = re.compile(r&#39;&lt;div\s+class=&quot;(result|result-op)\s+c-container\s+.*?&lt;a.*?&gt;(.*?)&lt;/a&gt;&#39;, re.I | re.S)        results = re.finditer(pattern, self.page)        result = []        for i in results:            result.append(i.group(2))        pattern_clean = re.compile(r&quot;&lt;em&gt;|&lt;/em&gt;|&#39;|\[|\]&quot;, re.I | re.S)        clean_result = re.sub(pattern_clean, &#39;&#39;, str(result))        self.text_outputbox.setText(clean_result)if __name__ == &#39;__main__&#39;:    app = QApplication(sys.argv)    myWin = my_main_window()    myWin.show()    sys.exit(app.exec())</code></pre>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式学习</title>
    <link href="/2020/02/22/%E9%95%BF%E7%9F%A5%E8%AF%86/%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/02/22/%E9%95%BF%E7%9F%A5%E8%AF%86/%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基本认识和元字符"><a href="#基本认识和元字符" class="headerlink" title="基本认识和元字符"></a>基本认识和元字符</h1><p>*任意长度字符串<br>？长度为1的任意字符串  </p><h2 id="元字符概念"><a href="#元字符概念" class="headerlink" title="元字符概念"></a><strong>元字符概念</strong></h2><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配出换行符外任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a><strong>反义</strong></h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母或数字或下划线或汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词的开始或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了X意外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母意外的任意字符</td></tr></tbody></table><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a><strong>字符转义</strong></h2><ul><li>匹配.或者?这样的字符</li><li>转义字符\</li><li>.*?</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><p><img src="/images/pasted-14.png" srcset="/img/loading.gif" alt="1"></p><h1 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h1><h2 id="重复模式"><a href="#重复模式" class="headerlink" title="重复模式"></a>重复模式</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或者更多次</td></tr><tr><td>+</td><td>重复一次或者多次</td></tr><tr><td>？</td><td>重复零次或者一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或者更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><p><img src="/images/pasted-15.png" srcset="/img/loading.gif" alt="2"><br>|表示分支条件  </p><blockquote><p>条件1：  </p></blockquote><p>0\d{2}-\d{8}<br>0然后两位数字-八位数字  </p><blockquote><p>条件二  </p></blockquote><p>0然后三位数字-七位数字<br>如果满足条件一就不执行条件二了</p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p><img src="/images/pasted-16.png" srcset="/img/loading.gif" alt="3"><br>(?0\d{2}[)-]?\d{8}<br>（出现零次或者一次，然后0接下来两位数字，)-打包出现零次，然后八位数字<br><em>这个左右括号没有做平衡</em>  </p><h1 id="分组-amp-贪婪与懒惰"><a href="#分组-amp-贪婪与懒惰" class="headerlink" title="分组&amp;贪婪与懒惰"></a>分组&amp;贪婪与懒惰</h1><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p><img src="/images/pasted-18.png" srcset="/img/loading.gif" alt="4"></p><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p><img src="/images/pasted-13.png" srcset="/img/loading.gif" alt="5"></p><p><strong>懒惰</strong>  </p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+？</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>？？</td><td>重复0次或者1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr><tr><td>## 处理选项</td><td></td></tr></tbody></table><p><img src="/images/pasted-17.png" srcset="/img/loading.gif" alt="6"></p><h1 id="高阶讲解"><a href="#高阶讲解" class="headerlink" title="高阶讲解"></a>高阶讲解</h1><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p><img src="/images/pasted-19.png" srcset="/img/loading.gif" alt="7"></p><h2 id="零宽断言（真假）"><a href="#零宽断言（真假）" class="headerlink" title="零宽断言（真假）"></a>零宽断言（真假）</h2><p><img src="/images/pasted-20.png" srcset="/img/loading.gif" alt="8"></p><h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p><img src="/images/pasted-21.png" srcset="/img/loading.gif" alt="9"></p><h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p><img src="/images/pasted-22.png" srcset="/img/loading.gif" alt="10"></p><p><strong>例子</strong></p><p><img src="/images/pasted-23.png" srcset="/img/loading.gif" alt="11"></p><pre><code>&lt;                                        #最外层的左括号    [^&lt;&gt;]*                               #最外层的左括号后面的不是括号的内容    (       (           (?&#39;Open&#39;&lt;)                    #碰到了左括号，在黑板上写一个“open”          |           (?&#39;-Open&#39;&gt;)                   #碰到了右括号，擦掉一个“open”          |  [^&lt;&gt;]*                      #匹配右括号后面不是括号的内容       )+    )*    (?(Open)(?!))                        #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的“open”，有的话匹配失败&gt;                                        #最外层的右括号</code></pre><p><em>仅支持.net</em></p><blockquote><p>参考资料：<a href="https://www.bilibili.com/video/av47287083?p=10" target="_blank" rel="noopener">https://www.bilibili.com/video/av47287083?p=10</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python爬虫一：分析豆瓣中正在上映的电影短评</title>
    <link href="/2020/02/21/%E9%95%BF%E7%9F%A5%E8%AF%86/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B8%80%EF%BC%9A%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E4%B8%AD%E6%9C%80%E6%96%B0%E7%94%B5%E5%BD%B1%E7%9A%84%E5%BD%B1%E8%AF%84/"/>
    <url>/2020/02/21/%E9%95%BF%E7%9F%A5%E8%AF%86/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B8%80%EF%BC%9A%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E4%B8%AD%E6%9C%80%E6%96%B0%E7%94%B5%E5%BD%B1%E7%9A%84%E5%BD%B1%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p>用python写爬虫抓取豆瓣短评并进行词云展示</p><h1 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h1><p>主要做了三件事：</p><ul><li>抓取网页数据</li><li>清理数据</li><li>进行词云展示</li></ul><h1 id="抓取网页数据"><a href="#抓取网页数据" class="headerlink" title="抓取网页数据"></a>抓取网页数据</h1><p><strong>第一步要对网页进行访问，python中使用的是urllib库。代码如下：</strong></p><pre><code class="python">import urlliburl = &#39;https://movie.douban.com/cinema/nowplaying/suzhou/&#39;head = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&#39;}request = urllib.request.Request(url = url, headers = head)resp = urllib.request.urlopen(request)html_data = resp.read().decode(&#39;utf-8&#39;)print(html_data)</code></pre><p>其中<a href="https://movie.douban.com/cinema/nowplaying/suzhou/" target="_blank" rel="noopener">https://movie.douban.com/cinema/nowplaying/suzhou/</a> ，可以在浏览器中输入该网址进行查看。<br>html_data是字符串类型的变量，里面存放了网页的html代码。<br>输入print(html_data)可以查看，如下图所示：</p><p><img src="/images/pasted-2.png" srcset="/img/loading.gif" alt="图片1"></p><p><strong>第二步，需要对得到的html代码进行解析，从里面提取我们需要的数据。</strong><br>在python中使用BeautifulSoup库进行html代码的解析。<br><del>（注：如果没有安装此库，则使用pip install BeautifulSoup进行安装即可！）<br>BeautifulSoup使用的格式如下：</del><br>pip install BeautifulSoup4</p><pre><code class="python">BeautifulSoup(html,&quot;html.parser&quot;)</code></pre><p>第一个参数为需要提取数据的html，第二个参数是指定解析器，然后使用find_all()读取html标签中的内容.  </p><p>但是html中有这么多的标签，该读取哪些标签呢？其实，最简单的办法是可以打开我们爬取网页的html代码，然后查看我们需要的数据在哪个html标签里面，再进行读取就可以了。如下图所示：</p><p><img src="/images/pasted-3.png" srcset="/img/loading.gif" alt="图片2"><br>从上图中可以看出在<em>div id=”nowplaying”</em>标签开始是我们想要的数据，里面有电影的名称、评分、主演等信息。所以相应的代码编写如下：</p><pre><code class="python">from bs4 import BeautifulSoup as bssoup = bs(html_data, &#39;html.parser&#39;)nowplaying_movie = soup.find_all(&#39;div&#39;, id=&#39;nowplaying&#39;)nowplaying_movie_list = nowplaying_movie[0].find_all(&#39;li&#39;, class_=&#39;list-item&#39;)</code></pre><pre><code class="python">nowplaying_list = [] for item in nowplaying_movie_list:                nowplaying_dict = {}                nowplaying_dict[&#39;id&#39;] = item[&#39;data-subject&#39;]               for tag_img_item in item.find_all(&#39;img&#39;):                        nowplaying_dict[&#39;name&#39;] = tag_img_item[&#39;alt&#39;]                        nowplaying_list.append(nowplaying_dict)  </code></pre><p><img src="/images/pasted-4.png" srcset="/img/loading.gif" alt="图片3"></p><p>可以看到和豆瓣网址上面是匹配的。这样就得到了最新电影的信息了。接下来就要进行对最新电影短评进行分析了。例如《战狼2》的短评网址为：<a href="https://movie.douban.com/subject/26363254/comments?start=0&amp;limit=20" target="_blank" rel="noopener">https://movie.douban.com/subject/26363254/comments?start=0&amp;limit=20</a><br>其中26363254就是电影的id，start=0表示评论的第0条评论。</p><p>接下来接对该网址进行解析了。打开上图中的短评页面的html代码，我们发现关于评论的数据是在div标签的comment属性下面，如下图所示：</p><p><img src="/images/pasted-5.png" srcset="/img/loading.gif" alt="图片4"></p><p>因此对此标签进行解析，代码如下：</p><pre><code class="python">requrl = &#39;https://movie.douban.com/subject/&#39; + nowplaying_list[0][&#39;id&#39;] + &#39;/comments&#39; +&#39;?&#39; +&#39;start=0&#39; + &#39;&amp;limit=20&#39;resp = urllib.request.Request(url = requrl, headers = head)resp = urllib.request.urlopen(resp)html_data = resp.read().decode(&#39;utf-8&#39;)soup = bs(html_data, &#39;html.parser&#39;)comment_div_list = soup.find_all(&#39;div&#39;, class_ = &#39;comment&#39;)</code></pre><pre><code class="python">eachCommentList = []for item in comment_div_list:    if item.find_all(&#39;span&#39;, &#39;short&#39;)[0].string is not None:        eachCommentList.append(item.find_all(&#39;span&#39;, &#39;short&#39;)[0].string)</code></pre><p><img src="/images/pasted-7.png" srcset="/img/loading.gif" alt="图片5"></p><p>好的，至此我们已经爬取了豆瓣最近播放电影的评论数据，接下来就要对数据进行清洗和词云显示了。</p><h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><p>为了方便进行数据进行清洗，我们将列表中的数据放在一个字符串数组中，代码如下：</p><pre><code class="python">comments = &#39;&#39;for k in range(len(eachCommentList)):    comments = comments + (str(eachCommentList[k])).strip()</code></pre><p>使用print(comments)进行查看，如下图所示：</p><p><img src="/images/pasted-8.png" srcset="/img/loading.gif" alt="图片6"></p><p>可以看到所有的评论已经变成一个字符串了，但是我们发现评论中还有不少的标点符号等。这些符号对我们进行词频统计时根本没有用，因此要将它们清除。所用的方法是正则表达式。python中正则表达式是通过re模块来实现的。代码如下：</p><pre><code class="python">pattern = re.compile(r&#39;[\u4e00-\u9fa5]+&#39;)filterdata = re.findall(pattern, comments)cleaned_comments = &#39;&#39;.join(filterdata)</code></pre><p><img src="/images/pasted-9.png" srcset="/img/loading.gif" alt="7"><br>我们可以看到此时评论数据中已经没有那些标点符号了，数据变得“干净”了很多。</p><p>因此要进行词频统计，所以先要进行中文分词操作。在这里我使用的是结巴分词。如果没有安装结巴分词，可以在控制台使用pip install jieba进行安装。</p><pre><code class="python">import jiebaimport pandas as pdsegment = jieba.lcut(cleaned_comments)words_df = pd.DataFrame({&#39;segment&#39;:segment})</code></pre><p>因为结巴分词要用到pandas，所以我们这里加载了pandas包。可以使用words_df.head()查看分词之后的结果，如下图所示：</p><p><img src="/images/pasted-10.png" srcset="/img/loading.gif" alt="8"><br>从上图可以看到我们的数据中有“看”、“太”、“的”等虚词（停用词），而这些词在任何场景中都是高频词，并且没有实际的含义，所以我们要将他们清除。</p><p>我把停用词放在一个stopwords.txt文件中，将我们的数据与停用词进行比对即可（注：<a href="https://github.com/captain-fat/short_text_classification/tree/master/conf" target="_blank" rel="noopener">https://github.com/captain-fat/short_text_classification/tree/master/conf</a> ）<br>去停用词代码如下：</p><pre><code class="python">stopwords = pd.read_csv(&#39;chineseStopWords.txt&#39;,index_col=False,quoting=3,sep=&quot;\t&quot;,names=[&#39;stopword&#39;], encoding=&#39;gb18030&#39;)#可能用&#39;utf-8&#39;words_df = words_df[~words_df.segment.isin(stopwords.stopword)]</code></pre><p>继续使用words_df.head()语句来查看结果，如下图所示，停用词已经被除去了。<br><img src="/images/pasted-11.png" srcset="/img/loading.gif" alt="9"></p><p>接下来就要进行词频统计了，代码如下：</p><pre><code class="python">import numpy as npwords_stat = words_df.groupby(by=[&#39;segment&#39;])[&#39;segment&#39;].agg({&quot;计数&quot;:np.size})words_stat = words_stat.reset_index().sort_values(by=[&#39;计数&#39;], ascending = False)</code></pre><blockquote><p>FutureWarning: using a dict on a Series for aggregation<br>is deprecated and will be removed in a future version. Use                 named aggregation instead.   </p><blockquote><blockquote><p>grouper.agg(name_1=func_1, name_2=func_2)<br>  “””Entry point for launching an IPython kernel.</p></blockquote></blockquote></blockquote><h1 id="词云展示"><a href="#词云展示" class="headerlink" title="词云展示"></a>词云展示</h1><p>代码如下：</p><pre><code class="python">import matplotlib.pyplot as plt%matplotlib inlineimport matplotlibmatplotlib.rcParams[&#39;figure.figsize&#39;] = (10.0, 5.0)from wordcloud import WordCloud#词云包wordcloud=WordCloud(font_path=&quot;simhei.ttf&quot;,background_color=&quot;white&quot;,max_font_size=80) #指定字体类型、字体大小和字体颜色word_frequence = {x[0]:x[1] for x in words_stat.head(1000).values}word_frequence_list = []for key in word_frequence:    temp = (key,word_frequence[key])    word_frequence_list.append(temp)word_frequence_list = dict(word_frequence_list)wordcloud=wordcloud.fit_words(word_frequence_list)plt.imshow(wordcloud)</code></pre><p><img src="/images/pasted-12.png" srcset="/img/loading.gif" alt="结果"></p><p>完整程序</p><pre><code class="python">import urllibfrom bs4 import BeautifulSoup as bsimport reimport jiebaimport pandas as pdimport numpy as npurl = &#39;https://movie.douban.com/cinema/nowplaying/suzhou/&#39;head = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&#39;}request = urllib.request.Request(url = url, headers = head)resp = urllib.request.urlopen(request)html_data = resp.read().decode(&#39;utf-8&#39;)print(html_data)soup = bs(html_data, &#39;html.parser&#39;)nowplaying_movie = soup.find_all(&#39;div&#39;, id=&#39;nowplaying&#39;)nowplaying_movie_list = nowplaying_movie[0].find_all(&#39;li&#39;, class_=&#39;list-item&#39;)nowplaying_list = []for item in nowplaying_movie_list:    nowplaying_dict = {}    nowplaying_dict[&#39;id&#39;] = item[&#39;data-subject&#39;]    for tag_img_item in item.find_all(&#39;img&#39;):        nowplaying_dict[&#39;name&#39;] = tag_img_item[&#39;alt&#39;]        nowplaying_list.append(nowplaying_dict)requrl = &#39;https://movie.douban.com/subject/&#39; + nowplaying_list[0][&#39;id&#39;] + &#39;/comments&#39; +&#39;?&#39; +&#39;start=0&#39; + &#39;&amp;limit=20&#39;resp = urllib.request.Request(url = requrl, headers = head)resp = urllib.request.urlopen(resp)html_data = resp.read().decode(&#39;utf-8&#39;)soup = bs(html_data, &#39;html.parser&#39;)comment_div_list = soup.find_all(&#39;div&#39;, class_ = &#39;comment&#39;)eachCommentList = []for item in comment_div_list:    if item.find_all(&#39;span&#39;, &#39;short&#39;)[0].string is not None:        eachCommentList.append(item.find_all(&#39;span&#39;, &#39;short&#39;)[0].string)comments = &#39;&#39;for k in range(len(eachCommentList)):    comments = comments + (str(eachCommentList[k])).strip()pattern = re.compile(r&#39;[\u4e00-\u9fa5]+&#39;)filterdata = re.findall(pattern, comments)cleaned_comments = &#39;&#39;.join(filterdata)segment = jieba.lcut(cleaned_comments)words_df = pd.DataFrame({&#39;segment&#39;:segment})stopwords = pd.read_csv(&#39;chineseStopWords.txt&#39;,index_col=False,quoting=3,sep=&quot;\t&quot;,names=[&#39;stopword&#39;], encoding=&#39;gb18030&#39;)words_df = words_df[~words_df.segment.isin(stopwords.stopword)]words_stat = words_df.groupby(by=[&#39;segment&#39;])[&#39;segment&#39;].agg({&quot;计数&quot;:np.size})words_stat = words_stat.reset_index().sort_values(by=[&#39;计数&#39;], ascending = False)import matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;figure.figsize&#39;] = (10.0, 5.0)from wordcloud import WordCloud#词云包wordcloud=WordCloud(font_path=&quot;simhei.ttf&quot;,background_color=&quot;white&quot;,max_font_size=80) #指定字体类型、字体大小和字体颜色word_frequence = {x[0]:x[1] for x in words_stat.head(1000).values}word_frequence_list = []for key in word_frequence:    temp = (key,word_frequence[key])    word_frequence_list.append(temp)word_frequence_list = dict(word_frequence_list)wordcloud=wordcloud.fit_words(word_frequence_list)plt.imshow(wordcloud)</code></pre><p>参考：<br><a href="https://segmentfault.com/a/1190000010473819" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010473819</a></p>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown用法（转载）</title>
    <link href="/2020/02/19/%E9%95%BF%E7%9F%A5%E8%AF%86/arkdown%E7%94%A8%E6%B3%95/"/>
    <url>/2020/02/19/%E9%95%BF%E7%9F%A5%E8%AF%86/arkdown%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级的<strong>「标记语言」</strong>，优点在于</p><ul><li><p>专注你的文字内容而不是排版样式。</p></li><li><p>轻松的导出 HTML、PDF 和本身的 .md 文件。</p></li><li><p>纯文本内容，兼容所有的文本编辑器与字处理软件。</p></li><li><p>可读，直观。适合所有人的写作语言。</p><blockquote><p>并且具有以下特点：</p></blockquote></li><li><p>自动生成目录</p></li><li><p>代码块高亮</p></li><li><p>引用展示</p></li><li><p>表格插入</p></li><li><p>图片插入</p></li><li><p>强调显示</p></li><li><p>列表显示</p></li><li><p>自动URL链接  </p></li></ul><blockquote><p>Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。</p></blockquote><h1 id="语法简明概述"><a href="#语法简明概述" class="headerlink" title="语法简明概述"></a>语法简明概述</h1><p>分段 两个回车<br>换行 两个空格 + 回车<br>标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题<br>强调 <strong>文字</strong> ， <strong>文字</strong> ， <em>文字</em> ， <em>文字</em> ， <del>文字</del><br>引用 &gt; 注意后面紧跟个空格<br>表格 - 和 | 分割行和列 ， : 控制对其方式<br>代码块 四个空格 开头或， 使用<code>代码内容</code><br>链接 <a href="链接地址">文字</a><br>图片 <img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" srcset="/img/loading.gif" alt="图片说明"> ，地址可以是本地路劲，也可以是网络地址<br>列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><pre><code class="markdown"># 欢迎使用Markdown编辑器写博客   //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入                     //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题                    //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题                   //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题                  //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题                 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt;####### 七级标题                //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行）二级标题                        //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;----                           //这里添加四个&#39;－&#39; （减号）</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><pre><code class="markdown">这是一级标题===这是二级标题---</code></pre><p>该方法仅支持二级标题</p><blockquote><p>这里不做展示了，影响目录的展示。</p></blockquote><h1 id="内容强调"><a href="#内容强调" class="headerlink" title="内容强调"></a>内容强调</h1><h2 id="加粗、斜体"><a href="#加粗、斜体" class="headerlink" title="加粗、斜体"></a>加粗、斜体</h2><pre><code class="markdown">字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示</code></pre><p>字体 <strong>加粗</strong> 显示<br>字体 <em>斜体</em> 显示<br>字体 <strong><em>加粗并斜体</em></strong> 显示</p><pre><code class="markdown">字体 __加粗__ 显示字体 _斜体_ 显示字体 ___加粗并斜体___ 显示组合 *__加粗并斜体__* 显示</code></pre><p>字体 <strong>加粗</strong> 显示<br>字体 <em>斜体</em> 显示<br>字体 <strong><em>加粗并斜体</em></strong> 显示<br>组合 <em><strong>加粗并斜体</strong></em> 显示  </p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><pre><code class="markdown">这样来 ~~删除一段文本~~</code></pre><p>这样来 <del>删除一段文本</del></p><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><pre><code class="markdown">使用&lt;code&gt;\`&lt;/code&gt;来强调字符   //想打出  ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调  比如`突出背景色`来显示强调效果</code></pre><p>使用<code>`</code>来强调字符<br>比如<code>突出背景色</code>来显示强调效果</p><h2 id="引用显示"><a href="#引用显示" class="headerlink" title="引用显示"></a>引用显示</h2><p>引用过程中任然支持Markdown语法！</p><h3 id="标准使用"><a href="#标准使用" class="headerlink" title="标准使用"></a>标准使用</h3><pre><code class="markdown">&gt; 每行开始都使用 &#39;&gt;&#39;；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。  &gt; 还在引用中！两个回车结束引用！</code></pre><blockquote><p>每行开始都使用 ‘&gt;’；<br>引用<strong>开始</strong>；<br>引用<strong>换行</strong>；<br>引用<strong>结束</strong>。<br>还在引用中！<br>两个回车结束引用！</p></blockquote><h3 id="省略使用"><a href="#省略使用" class="headerlink" title="省略使用"></a>省略使用</h3><pre><code class="markdown">&gt; 仅第一行加应用；引用**开始**；引用**换行**；引用**结束**；两个回车结束引用,不在引用范围内了！</code></pre><blockquote><p>仅第一行加应用；<br>引用<strong>开始</strong>；<br>引用<strong>换行</strong>；<br>引用<strong>结束</strong>；  </p></blockquote><p>两个回车结束引用,不在引用范围内了！</p><h3 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h3><pre><code class="markdown">&gt; 动物&gt;&gt; 水生动物&gt;&gt; 陆生动物&gt;&gt;&gt; 猴子&gt;&gt;&gt; 人&gt;&gt;&gt;&gt; 程序猿&gt;&gt;&gt;&gt; 攻城狮&gt;&gt;产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱   //这里需要注意，没有空行间隔，忽略降级引用标记&gt;&gt; 两栖类动物&gt;&gt;&gt; 大鳄鱼唐老鸭两个回车结束引用,不在引用范围内了！</code></pre><blockquote><p>动物</p><blockquote><p>水生动物<br>陆生动物</p><blockquote><p>猴子<br>人</p><blockquote><p>程序猿<br>攻城狮<br>产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记<br>射鸡虱   //这里需要注意，没有空行间隔，忽略降级引用标记<br>两栖类动物<br>大鳄鱼<br>唐老鸭<br>两个回车结束引用,不在引用范围内了！</p></blockquote></blockquote></blockquote></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表格语法：</p><pre><code class="markdown">列1   | 列2 | 列3 ----- | --- | ---- 第1行 | 12  | 13  第2行 | 22  | 23  第3行 | 32  | 33</code></pre><table><thead><tr><th>列1</th><th>列2</th><th>列3</th></tr></thead><tbody><tr><td>第1行</td><td>12</td><td>13</td></tr><tr><td>第2行</td><td>22</td><td>23</td></tr><tr><td>第3行</td><td>32</td><td>33</td></tr></tbody></table><p>可以使用冒号来定义对齐方式：</p><pre><code class="markdown">| 左对齐    |  右对齐 | 居中 || :-------- | -------:| :--: || Computer  | 5000 元 |  1台 || Phone     | 1999 元 |  1部 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">5000 元</td><td align="center">1台</td></tr><tr><td align="left">Phone</td><td align="right">1999 元</td><td align="center">1部</td></tr></tbody></table><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>代码块语法遵循标准 markdown 代码，使用 <code>开始，</code> 结束，例如：</p><pre><code class="Python">#!/usr/bin/env python# -*- coding: utf-8 -*-print &#39;Hello World!</code></pre><pre><code>以上代码框及代码输入内容</code></pre><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-print &#39;Hello World!&#39;</code></pre><h2 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h2><p>如何在代码块中打出 ```</p><pre><code class="markdown">    ````    ```    复制到你的`markdown`中看看去吧！    ```    ````</code></pre><p>实际上是使用 4个<code>包含 3个</code> 就可以了，想表示更多，最外层+1就好了。</p><pre><code class="markdown">    ````    ```    ```    ````</code></pre><h1 id="链接插入"><a href="#链接插入" class="headerlink" title="链接插入"></a>链接插入</h1><pre><code class="markdown">[首页](http://yifan.press)[我的信息](/about/)</code></pre><p><a href="http://yifan.press">首页</a><br><a href="/about/">我的信息</a></p><p>图片插入</p><pre><code class="markdown">![我的头像](http://yifan.press/img/avatar.png)![我的头像](images/avatar.png)</code></pre><p><img src="https//yifan.press/img/avatar.png" srcset="/img/loading.gif" alt="我的头像"><br><img src="/images/avatar.png" srcset="/img/loading.gif" alt="我的头像"></p><h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><pre><code class="markdown">***---</code></pre><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><pre><code class="markdown">* `*`列表展示* `*`列表展示 * `*`列表展示+ `+`列表展示+ `+`列表展示 + `+`列表展示- `-`列表展示- `-`列表展示 - `-`列表展示</code></pre><ul><li><code>*</code>列表展示</li><li><code>*</code>列表展示<ul><li><code>*</code>列表展示</li></ul></li></ul><ul><li><code>+</code>列表展示</li><li><code>+</code>列表展示<ul><li><code>+</code>列表展示</li></ul></li></ul><ul><li><code>-</code>列表展示</li><li><code>-</code>列表展示<ul><li><code>-</code>列表展示</li></ul></li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>这种方式不用手动设置序号，自动生成列表序列</p><pre><code class="markdown">1. **我是一级序列** 1. **我是一级序列** 1. **我是一级序列**  1. *我是二级序列*  1. *我是二级序列*  1. *我是二级序列* 1. **我是一级序列** 1. **我是一级序列**  1. *我是二级序列*  1. *我是二级序列*   1. 还是二级序列，没有三级序列\</code></pre><ol><li><strong>我是一级序列</strong> </li><li><strong>我是一级序列</strong> </li><li><strong>我是一级序列</strong> <ol><li><em>我是二级序列</em> </li><li><em>我是二级序列</em> </li><li><em>我是二级序列</em> </li></ol></li><li><strong>我是一级序列</strong> </li><li><strong>我是一级序列</strong> <ol><li><em>我是二级序列</em> </li><li><em>我是二级序列</em> </li><li>还是二级序列，没有三级序列\序列一个空格，但是任然是二级序列</li></ol></li></ol><h1 id="链接自动检测"><a href="#链接自动检测" class="headerlink" title="链接自动检测"></a>链接自动检测</h1><pre><code class="markdown">首页:http://yifan.press我的信息:http://yifan.press/about/</code></pre><p>首页:<a href="http://yifan.press">http://yifan.press</a><br>我的信息:<a href="http://yifan.press/about/">http://yifan.press/about/</a></p><h1 id="特殊符号处理"><a href="#特殊符号处理" class="headerlink" title="特殊符号处理"></a>特殊符号处理</h1><pre><code class="markdown">\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><blockquote><p>本文作者： zhuzhuxia<br>本文链接： <a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html</a><br>温馨提示： 由于原创文章，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。  </p></blockquote><blockquote><p>感谢：<a href="https://www.jianshu.com/p/335db5716248" target="_blank" rel="noopener">https://www.jianshu.com/p/335db5716248</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫-get请求示例</title>
    <link href="/2020/02/19/%E9%95%BF%E7%9F%A5%E8%AF%86/%E7%88%AC%E8%99%AB-get%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/"/>
    <url>/2020/02/19/%E9%95%BF%E7%9F%A5%E8%AF%86/%E7%88%AC%E8%99%AB-get%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>GET请求一般用于我们向服务器查询的过程，比如说，百度搜索“宁哥的小站”，如图所示，浏览器的url会跳转成如图所示</p><p><img src="/images/pasted-0.png" srcset="/img/loading.gif" alt="图像1"></p><p>在其中我们可以看到在”<a href="http://www.baidu.com/s?”" target="_blank" rel="noopener">http://www.baidu.com/s?”</a> 之后出现一个长长的字符串，其中就包含我们要查询的关键词。那么，我们在编程过程中，如何配置这段字符串参数呢？</p><p>在Chrome浏览器中，我们可以看到，请求的数据包含在请求头的Query String Parameters中，其实我们可以将这些字段都写在程序中，也可以摘取其中必要的部分，而不是全部。</p><p><img src="/images/pasted-1.png" srcset="/img/loading.gif" alt="图像2"></p><p>比较关键的是wd字段，这里我们只是把wd字段提取出来，写成词典，然后通过程序编码，配置成GET请求的url，再通过一般的程序抓取手段，可以得到我们查询的页面。程序如下：</p><p>  <strong><em>urllib有些用法变了，更新了下(2020/2/19)</em></strong></p><pre><code class="python">import urlliburl = &quot;http://www.baidu.com/s&quot;data = {    &#39;wd&#39;: &quot;测试&quot;}data = urllib.parse.urlencode(data) #编码工作，由dict转成stringfull_url = url + &#39;?&#39; + data #Get请求发送print(full_url)response = urllib.request.urlopen(full_url)print(response.read())</code></pre><p>转载请注明：宁哥的小站 » 3. 网络爬虫-GET请求示例</p>]]></content>
    
    
    <categories>
      
      <category>长知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>巴意行</title>
    <link href="/2020/02/17/%E5%B7%B4%E6%84%8F%E8%A1%8C/"/>
    <url>/2020/02/17/%E5%B7%B4%E6%84%8F%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please.." data-whm="Sorry, wrong hash."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Hey, password is required here." /><label>Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="3be2431fcdba7d480bcf762626301caf29037b7ec5530fb60df7d0c6e4e9e27b">f2fd406b5d28eb48ecc341e8ed8ec46e6fa5bb41eb4dbadcdaab53489ae1f1364f690a8268b6f97b0ddd89addfc744dd007a212c7d95604e89950e77b7f84df6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2020/02/17/test/"/>
    <url>/2020/02/17/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/02/16/hello-world/"/>
    <url>/2020/02/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
